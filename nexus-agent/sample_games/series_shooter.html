<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Geometric Gradients - Math Shooter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            background: #050505;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace; /* Digital theme font */
        }

        canvas {
            display: block;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }
    </style>
</head>

<body>
    <!-- LOAD KAPLAY VIA CDN -->
    <script src="https://unpkg.com/kaplay@3001/dist/kaplay.js"></script>
    <script>
        /**
         * GEOMETRIC GRADIENTS
         * A math-based Shoot 'em Up.
         * 
         * LEARNING OBJECTIVE:
         * Recognize geometric sequences and apply the finite sum formula: S_n = a(1-r^n)/(1-r).
         * 
         * MECHANICS:
         * - Shoot enemies to gain points.
         * - Every 1000 points, a "Sum Formula Gate" activates.
         * - Calculate the sum of the displayed geometric series.
         * - Shoot the correct orb to proceed and gain a fire-rate buff.
         */

        // =============================================
        //  CONFIG
        // =============================================
        const C = {
            playerSpeed: 300,
            bulletSpeed: 700,
            baseFireRate: 0.12,
            playerHP: 5,
            spawnRate: 1.2,
            enemySpeed: [80, 200],
            enemyHP: [1, 3],
            enemyFireRate: 1.5,
            bg: [10, 20, 10], // Dark digital green
            playerCol: [0, 255, 150], // Neon Green
            bulletCol: [0, 255, 255], // Cyan Data Pulse
            enemyBulletCol: [255, 100, 100],
            gateThreshold: 1000, // Points needed to trigger gate
        };

        // Initialize Kaplay
        kaplay({
            width: 480,
            height: 700,
            background: C.bg,
            crisp: true,
            letterbox: true,
            font: "monospace" // Use built-in monospace-like font handling if available, or fallback
        });

        // =============================================
        //  ASSETS & HELPERS
        // =============================================

        // Digital Grid Background
        // Static vertical lines, scrolling horizontal lines
        function makeGrid() {
            // Static Vertical Lines
            for (let x = 0; x <= width(); x += 40) {
                add([
                    rect(1, height()),
                    pos(x, 0),
                    color(0, 60, 20),
                    z(-10),
                    fixed(),
                ]);
            }
            
            // Scrolling Horizontal Lines
            loop(0.4, () => {
                add([
                    rect(width(), 1),
                    pos(0, -10),
                    color(0, 60, 20),
                    move(DOWN, 100), // Move down to create flow
                    z(-10),
                    offscreen({ destroy: true }),
                    "gridLine"
                ]);
            });
        }

        // =============================================
        //  GAME SCENE
        // =============================================
        scene("game", () => {
            makeGrid();

            // -- STATE --
            let score = 0;
            let fireTimer = 0;
            let gameOver = false;
            let spawnTimer = 0;
            let difficulty = 1;
            let extraDiff = 0; // Added difficulty after passing gates
            
            // Gate State
            let isGateActive = false;
            let nextGateScore = C.gateThreshold;
            let fireRateBuffTimer = 0; // >0 means buff active

            // -- PLAYER: Vector Ship (Polygon) --
            // Shape: A sleek triangle with a notch
            const player = add([
                polygon([vec2(0, -20), vec2(-12, 15), vec2(0, 8), vec2(12, 15)]),
                pos(width() / 2, height() - 80),
                area(),
                anchor("center"),
                color(...C.playerCol),
                outline(2, rgb(200, 255, 200)),
                z(10),
                { hp: C.playerHP, invuln: 0 },
                "player",
            ]);

            // -- HUD --
            const scoreTxt = add([
                text("POINTS: 0", { size: 20, font: "monospace" }),
                pos(width() / 2, 10), anchor("top"), color(0, 255, 0), fixed(), z(50),
            ]);
            
            const hpTxt = add([
                text("INTEGRITY: @@@@@", { size: 16, font: "monospace" }),
                pos(10, 10), color(0, 200, 255), fixed(), z(50),
            ]);

            const buffTxt = add([
                text("OVERCLOCK ACTIVE", { size: 14, font: "monospace" }),
                pos(width()/2, 40), anchor("top"), color(255, 255, 0), fixed(), z(50),
                opacity(0)
            ]);

            function updateHUD() {
                scoreTxt.text = `POINTS: ${score}`;
                let hearts = "";
                for (let i = 0; i < player.hp; i++) hearts += "♥ ";
                hpTxt.text = `INTEGRITY: ${hearts.trim()}`;
            }
            updateHUD();

            // -- MOVEMENT --
            // Player controls remain active even during Gate to allow aiming
            const moveSpeed = C.playerSpeed;
            onKeyDown("left", () => { if (!gameOver) player.move(-moveSpeed, 0); });
            onKeyDown("right", () => { if (!gameOver) player.move(moveSpeed, 0); });
            onKeyDown("up", () => { if (!gameOver) player.move(0, -moveSpeed); });
            onKeyDown("down", () => { if (!gameOver) player.move(0, moveSpeed); });
            onKeyDown("a", () => { if (!gameOver) player.move(-moveSpeed, 0); });
            onKeyDown("d", () => { if (!gameOver) player.move(moveSpeed, 0); });
            onKeyDown("w", () => { if (!gameOver) player.move(0, -moveSpeed); });
            onKeyDown("s", () => { if (!gameOver) player.move(0, moveSpeed); });

            player.onUpdate(() => {
                player.pos.x = clamp(player.pos.x, 20, width() - 20);
                player.pos.y = clamp(player.pos.y, 40, height() - 20);
                
                // Invulnerability flicker
                if (player.invuln > 0) {
                    player.invuln -= dt();
                    player.opacity = wave(0.3, 1, time() * 20);
                } else {
                    player.opacity = 1;
                }

                // Buff Timer
                if (fireRateBuffTimer > 0) {
                    fireRateBuffTimer -= dt();
                    buffTxt.opacity = wave(0.5, 1, time() * 10);
                } else {
                    buffTxt.opacity = 0;
                }
            });

            // -- SHOOTING --
            onUpdate(() => {
                if (gameOver) return;
                fireTimer -= dt();
                const shooting = isKeyDown("z") || isKeyDown("space");
                
                // Apply buff if active
                const currentFireRate = (fireRateBuffTimer > 0) ? C.baseFireRate * 0.5 : C.baseFireRate;

                if (shooting && fireTimer <= 0) {
                    fireTimer = currentFireRate;
                    // "Data Pulse" bullets (circles)
                    add([
                        circle(4),
                        pos(player.pos.x, player.pos.y - 20),
                        area(),
                        anchor("center"),
                        color(...C.bulletCol),
                        move(UP, C.bulletSpeed),
                        offscreen({ destroy: true }),
                        z(8),
                        "pbullet",
                    ]);
                }
            });

            // =============================================
            //  SUM FORMULA GATE ADDON
            // =============================================
            function startSumGate() {
                isGateActive = true;
                destroyAll("enemy");  // Clear screen
                destroyAll("ebullet");
                
                // 1. Generate Math Problem (Geometric Series)
                // S_n = a * (1 - r^n) / (1 - r)
                const r = choose([2, 3]);       // Common ratio
                const a = randi(2, 6);          // First term
                const n = choose([3, 4]);       // Number of terms

                // Calculate sequence and sum
                let sequence = [];
                let curr = a;
                let sum = 0;
                for(let i=0; i<n; i++){
                    sequence.push(curr);
                    sum += curr;
                    curr *= r;
                }
                const correctSum = sum;
                const seqString = sequence.join(" + ");

                // 2. UI Display
                // Background Panel
                add([
                    rect(420, 250),
                    pos(width()/2, height()/2 - 50),
                    anchor("center"),
                    color(0, 20, 0),
                    outline(4, rgb(0, 255, 0)),
                    opacity(0.9),
                    z(90),
                    "gateUI"
                ]);

                // Labels
                add([
                    text("SUM FORMULA GATE", { size: 24, font: "monospace" }),
                    pos(width()/2, height()/2 - 140), anchor("center"), color(0, 255, 100), z(95), "gateUI"
                ]);
                add([
                    text(`${seqString}`, { size: 22, font: "monospace" }),
                    pos(width()/2, height()/2 - 90), anchor("center"), color(255, 255, 255), z(95), "gateUI"
                ]);
                add([
                    text(`Hint: S = a(1-r^n)/(1-r)\na=${a}, r=${r}, n=${n}`, { size: 16, font: "monospace", align: "center" }),
                    pos(width()/2, height()/2 - 30), anchor("center"), color(100, 200, 200), z(95), "gateUI"
                ]);
                add([
                    text("SHOOT THE CORRECT SUM!", { size: 18, font: "monospace" }),
                    pos(width()/2, height()/2 + 40), anchor("center"), color(255, 255, 0), z(95), "gateUI"
                ]);

                // 3. Spawn Calculation Orbs
                const answers = [correctSum];
                // Distractors: close math errors
                while(answers.length < 3) {
                    const wrong = correctSum + choose([-a, a, -10, 10, randi(-20, 20)]);
                    if(wrong > 0 && !answers.includes(wrong)) answers.push(wrong);
                }
                answers.sort(() => rand() - 0.5); // Shuffle

                // Place Orbs at bottom of gate area
                answers.forEach((ans, i) => {
                    const x = width()/2 + (i - 1) * 120;
                    const y = height()/2 + 180;
                    
                    const orb = add([
                        circle(35),
                        pos(x, y),
                        color(0, 0, 50),
                        outline(2, rgb(0, 255, 255)),
                        area(),
                        anchor("center"),
                        z(95),
                        "orb", // Tag
                        { value: ans, isCorrect: (ans === correctSum) }
                    ]);

                    // Orb Label
                    add([
                        text(`${ans}`, { size: 20, font: "monospace" }),
                        pos(orb.pos),
                        anchor("center"),
                        color(255, 255, 255),
                        z(96),
                        "orbLabel"
                    ]);
                });
            }

            // Handle Orb Collision
            onCollide("pbullet", "orb", (b, o) => {
                destroy(b);
                if (o.isCorrect) {
                    // SUCCESS
                    score += 500;
                    extraDiff += 0.2; // Increase difficulty permanently
                    fireRateBuffTimer = 10; // 10 seconds rapid fire
                    addKaboom(o.pos);
                    shake(5);
                    playSuccessEffect();
                } else {
                    // FAILURE
                    hurtPlayer(); // Penalty
                    addKaboom(o.pos);
                }
                
                // Cleanup Gate
                destroyAll("gateUI");
                destroyAll("orb");
                destroyAll("orbLabel");
                isGateActive = false;
                updateHUD();
            });

            function playSuccessEffect() {
                // Visual feedback for success
                const msg = add([
                    text("DATA DECRYPTED!", { size: 28, font: "monospace" }),
                    pos(width()/2, height()/2),
                    anchor("center"),
                    color(0, 255, 0),
                    move(UP, 50),
                    opacity(1),
                    z(200)
                ]);
                tween(1, 0, 1.5, (v) => msg.opacity = v, checkTweenEase).then(() => destroy(msg));
            }
            
            // Just a helper for tween ease
            function checkTweenEase(t) { return t; }


            // =============================================
            //  ENEMY SPAWNING & LOGIC
            // =============================================
            
            // Difficulty Scaling
            onUpdate(() => {
                if (gameOver) return;
                
                // Gate Trigger Check
                if (!isGateActive && score >= nextGateScore) {
                    startSumGate();
                    nextGateScore += 1000; // Next gate in 1000 pts
                    return; // Stop update logic for spawning
                }

                if (isGateActive) return; // Pause spawning during gate

                difficulty = 1 + (score / 2000) + extraDiff;
                
                spawnTimer -= dt();
                if (spawnTimer <= 0) {
                    spawnTimer = C.spawnRate / difficulty;
                    spawnEnemy();
                }
            });

            function spawnEnemy() {
                // Enemy Types:
                // 1. Arithmetic Drone (Basic): Straight line, '+' symbol
                // 2. Geometric Fractal (Fast): Zigzag, pulsing size
                // 3. Power Series (Tank): Slow, shoots, 'Σ' symbol
                
                const type = choose(["arith", "arith", "geo", "power"]);
                
                // Configs
                const configs = {
                    arith: { w: 30, hp: 1, spd: rand(80, 150), col: [50, 50, 200], pts: 100, label: "+" },
                    geo:   { w: 25, hp: 1, spd: rand(180, 280), col: [200, 50, 200], pts: 150, label: "" }, // Special behavior
                    power: { w: 40, hp: 3, spd: rand(40, 80),   col: [200, 100, 0], pts: 300, label: "Σ", shoots: true }
                };
                
                const conf = configs[type];
                const xPos = rand(30, width() - 30);

                const e = add([
                    rect(conf.w, conf.w), // Square base
                    pos(xPos, -40),
                    area(),
                    anchor("center"),
                    color(...conf.col),
                    outline(2, rgb(255, 255, 255)),
                    z(9),
                    { 
                        hp: conf.hp, 
                        pts: conf.pts, 
                        type: type,
                        fireCD: rand(0.5, C.enemyFireRate) 
                    },
                    "enemy"
                ]);

                // Label
                if (conf.label) {
                    e.add([
                        text(conf.label, { size: conf.w * 0.8, font: "monospace" }),
                        anchor("center"),
                        color(255, 255, 255)
                    ]);
                }

                // AI / Movement
                if (type === "geo") {
                    // Geometric Fractal: Pulsing size
                    e.onUpdate(() => {
                        e.move(Math.sin(time() * 5 + e.pos.x) * 100, conf.spd); // Zigzag
                        // Pulsing effect
                        const s = wave(0.8, 1.4, time() * 8);
                        e.scale = vec2(s, s); 
                    });
                } else {
                    // Standard move
                    e.onUpdate(() => { e.move(0, conf.spd); });
                }

                // Shooting Logic for Power Series Tank
                if (conf.shoots) {
                    e.onUpdate(() => {
                        if (gameOver || isGateActive) return;
                        e.fireCD -= dt();
                        if (e.fireCD <= 0) {
                            e.fireCD = C.enemyFireRate;
                            add([
                                circle(6),
                                pos(e.pos),
                                area(),
                                anchor("center"),
                                color(...C.enemyBulletCol),
                                move(DOWN, C.enemyBulletSpd),
                                offscreen({ destroy: true }),
                                z(8),
                                "ebullet"
                            ]);
                        }
                    });
                }
            }

            // Cleanup
            onUpdate("enemy", (e) => {
                if (e.pos.y > height() + 60) destroy(e);
            });


            // =============================================
            //  COLLISIONS
            // =============================================
            
            // Bullet vs Enemy
            onCollide("pbullet", "enemy", (b, e) => {
                destroy(b);
                e.hp--;
                // Flash white on hit
                e.color = rgb(255, 255, 255);
                wait(0.05, () => {
                    // Restore original color based on type
                    if(e.type === "arith") e.color = rgb(50, 50, 200);
                    if(e.type === "geo") e.color = rgb(200, 50, 200);
                    if(e.type === "power") e.color = rgb(200, 100, 0);
                });

                if (e.hp <= 0) {
                    score += e.pts;
                    addKaboom(e.pos);
                    destroy(e);
                    updateHUD();
                }
            });

            // Enemy Bullet vs Player
            onCollide("ebullet", "player", (b) => {
                destroy(b);
                hurtPlayer();
            });

            // Enemy Body vs Player
            onCollide("enemy", "player", (e) => {
                score += e.pts;
                addKaboom(e.pos);
                destroy(e);
                hurtPlayer();
                updateHUD();
            });

            function hurtPlayer() {
                if (player.invuln > 0 || gameOver) return;
                
                player.hp--;
                player.invuln = 1.5;
                shake(8);
                // Red flash overlay
                const flashOverlay = add([
                    rect(width(), height()),
                    color(255, 0, 0),
                    opacity(0.3),
                    fixed(),
                    z(200)
                ]);
                wait(0.1, () => destroy(flashOverlay));
                
                updateHUD();

                if (player.hp <= 0) {
                    gameOver = true;
                    addKaboom(player.pos);
                    player.opacity = 0;
                    wait(1, () => go("gameover", score));
                }
            }

            // Controls Hint
            add([
                text("WASD/ARROWS move | Z/SPACE shoot", { size: 12, font: "monospace" }),
                pos(width() / 2, height() - 10), anchor("bot"),
                color(100, 150, 100), fixed(), z(50),
            ]);
        });

        // =============================================
        //  GAME OVER SCENE
        // =============================================
        scene("gameover", (finalScore) => {
            makeGrid(); // Keep bg theme
            
            add([
                text("SYSTEM FAILURE", { size: 40, font: "monospace" }),
                pos(width()/2, height()/2 - 60), 
                anchor("center"), 
                color(255, 50, 50)
            ]);
            
            add([
                text(`FINAL SCORE: ${finalScore}`, { size: 24, font: "monospace" }),
                pos(width()/2, height()/2), 
                anchor("center"), 
                color(0, 255, 0)
            ]);
            
            add([
                text("Press SPACE to Reboot", { size: 16, font: "monospace" }),
                pos(width()/2, height()/2 + 60), 
                anchor("center"), 
                color(150, 150, 150)
            ]);

            onKeyPress("space", () => go("game"));
            onClick(() => go("game"));
        });

        // Start Game
        go("game");

    </script>
</body>
</html>