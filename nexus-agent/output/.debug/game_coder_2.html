<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Heights: Geometric Gateway</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a1a;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            display: block;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }
    </style>
</head>

<body>
    <!-- Using Kaplay.js from CDN -->
    <script src="https://unpkg.com/kaplay@3001/dist/kaplay.js"></script>
    <script>
        /**
         * EDUCATIONAL OBJECTIVES:
         * 1. Recognize geometric sequences (a, ar, ar^2...).
         * 2. Distinguish geometric growth (multiplication) from arithmetic growth (addition).
         * 3. Calculate the partial sum of a geometric series (Sn) to identify the correct exit.
         */

        // ============================================================
        //  GAME CONFIGURATION
        // ============================================================

        const CONFIG = {
            // Physics
            gravity: 1600,
            jumpForce: 650,
            moveSpeed: 300,
            maxFallSpeed: 800,

            // Camera
            cameraFollow: true,

            // Player
            playerStartPos: { x: 50, y: 0 },
            playerHealth: 3,

            // Visuals - Fractal Heights Theme
            bgColor: [16, 16, 37],         // Deep Fractal Blue
            floorColor: [26, 26, 64],      // Dark Platform Block
            floorOutline: [100, 100, 255], // Neon Blue Outline
            playerColor: [0, 255, 255],    // Vector Cyan
            hazardColor: [255, 50, 80],    // Error Red
            orbColor: [255, 0, 255],       // Term Orb Magenta
            impostorColor: [255, 100, 0],  // Impostor Orange
            portalColor: [180, 80, 255],   // Portal Purple
        };

        // ============================================================
        //  LEVEL MAPS
        // ============================================================
        // Symbols:
        //   = : solid ground (Fractal Block)
        //   - : platform (One-way)
        //   @ : player spawn
        //   $ : Potential Term Orb (Correct or Impostor)
        //   ^ : Static Error (Hazard)
        //   1, 2, 3 : Sum Portals (Exit choices)
        
        const LEVELS = [
            // --- Level 1 ---
            [
                "                                        ",
                "                                        ",
                "                                        ",
                "                         $   $          ",
                "                        ------          ",
                "            $  $                        ",
                "           ------           $  $        ",
                "                           ------    1  ",
                "    $  $                           ==== ",
                "   ------                            2  ",
                "                   $               ==== ",
                "  @              =====     ===       3  ",
                "========   ^^^  ========  ======  ======",
            ],
            // --- Level 2 ---
            [
                "                                        ",
                "                                   1    ",
                "                                  ===   ",
                "                       $  $             ",
                "                      ------       2    ",
                "           $                   $  ===   ",
                "          ---              ------       ",
                "                                   3    ",
                "    $         $     $             ===   ",
                "   ---    ------  -----                 ",
                "                                        ",
                "  @                          ===        ",
                "=====  ^^^  ====  ^^^  ====  ^^^^^^  ===",
            ],
        ];

        // ============================================================
        //  INITIALIZE KAPLAY
        // ============================================================
        kaplay({
            background: CONFIG.bgColor,
            width: 800,
            height: 480,
            scale: 1,
            crisp: true,
            global: true,
            buttons: {
                jump: { keyboard: ["space", "w", "up"], gamepad: ["south"] },
                left: { keyboard: ["a", "left"], gamepad: ["dpad-left"] },
                right: { keyboard: ["d", "right"], gamepad: ["dpad-right"] },
            },
        });

        // Helper: Random choice from array
        function choose(arr) {
            return arr[Math.floor(rand(0, arr.length))];
        }

        // ============================================================
        //  GAME LOGIC & LEVEL BUILDING
        // ============================================================

        const TILE = 32;

        // Stores level math state
        let levelMathState = {
            a: 2,           // First term
            r: 2,           // Common ratio
            correctSum: 0,  // Target Sum for the correct portal
            maxTerms: 0     // Total correct terms generated
        };

        function buildLevel(mapData, levelIdx) {
            const objects = { orbs: [], portals: [] };
            let spawnPos = vec2(CONFIG.playerStartPos.x, CONFIG.playerStartPos.y);

            // 1. Determine Math Rules for this Level
            if (levelIdx === 0) {
                levelMathState.a = 2;
                levelMathState.r = 2;
            } else {
                levelMathState.a = choose([2, 3]);
                levelMathState.r = choose([2, 3]);
            }
            
            // Reset state
            levelMathState.correctSum = 0;
            levelMathState.maxTerms = 0;

            // 2. Parse Map
            // We need to collect orb positions first to assign sequence values in order (left-to-right)
            let rawOrbs = [];

            for (let row = 0; row < mapData.length; row++) {
                for (let col = 0; col < mapData[row].length; col++) {
                    const ch = mapData[row][col];
                    const x = col * TILE;
                    const y = row * TILE;
                    const posVec = vec2(x, y);

                    switch (ch) {
                        case "=": // Fractal Block
                            add([
                                rect(TILE, TILE),
                                pos(posVec),
                                area(),
                                body({ isStatic: true }),
                                color(...CONFIG.floorColor),
                                outline(2, rgb(...CONFIG.floorOutline)),
                                "ground",
                            ]);
                            break;

                        case "-": // Platform
                            add([
                                rect(TILE, TILE / 2),
                                pos(x, y + TILE / 2),
                                area(),
                                body({ isStatic: true }),
                                color(...CONFIG.floorColor),
                                outline(2, rgb(100, 200, 255)),
                                "platform",
                            ]);
                            break;

                        case "@": // Player Spawn
                            spawnPos = vec2(x, y);
                            break;

                        case "$": // Potential Orb
                            rawOrbs.push({ x, y });
                            break;

                        case "^": // Static Error (Hazard)
                            add([
                                text("+", { size: 32, font: "monospace" }), // Reskin: "+" symbol
                                pos(x + TILE/2, y + TILE/2),
                                anchor("center"),
                                area({ shape: new Rect(vec2(-10, -10), 20, 20) }),
                                color(...CONFIG.hazardColor),
                                "hazard",
                                {
                                    update() {
                                        this.opacity = wave(0.5, 1, time() * 10); // Glitchy pulse
                                    }
                                }
                            ]);
                            break;

                        case "1":
                        case "2":
                        case "3": // Portals
                            const p = add([
                                rect(TILE, TILE * 1.5),
                                pos(x, y - TILE * 0.5),
                                area(),
                                anchor("topleft"),
                                color(...CONFIG.portalColor),
                                outline(2, rgb(255, 255, 255)),
                                opacity(0.8),
                                z(1),
                                "portal",
                                { 
                                    portalId: parseInt(ch),
                                    sumValue: 0 // Will be assigned after math generation
                                }
                            ]);
                            // Label for portal
                            p.add([
                                text("?", { size: 14, font: "monospace", align: "center" }),
                                pos(TILE/2, TILE/2),
                                anchor("center"),
                                color(255, 255, 255),
                                "portalLabel"
                            ]);
                            objects.portals.push(p);
                            break;
                    }
                }
            }

            // 3. Generate Math Sequence & Orbs
            // Sort orbs by X position to create a linear progression
            rawOrbs.sort((a, b) => a.x - b.x);

            let currentTermVal = levelMathState.a;
            
            rawOrbs.forEach((o, index) => {
                let isImpostor = false;
                
                // Logic: Every 3rd orb is an impostor in the linear path
                if ((index + 1) % 3 === 0) {
                    isImpostor = true;
                }

                let val = 0;
                if (isImpostor) {
                    // Arithmetic Impostor: a + (n * r) instead of a * r^n
                    // We ensure it's different from the geometric term
                    val = levelMathState.a + (index * levelMathState.r);
                    if (val === currentTermVal) val += 1; // Prevent accidental collision
                } else {
                    // Geometric Term
                    val = currentTermVal;
                    levelMathState.correctSum += val;
                    levelMathState.maxTerms++;
                    // Prepare next term
                    currentTermVal *= levelMathState.r;
                }

                // Spawn Orb
                const orb = add([
                    circle(14),
                    pos(o.x + TILE/2, o.y + TILE/2),
                    anchor("center"),
                    area(),
                    color(isImpostor ? CONFIG.impostorColor : CONFIG.orbColor),
                    outline(2, rgb(255, 255, 255)),
                    z(5),
                    "orb",
                    {
                        val: val,
                        isImpostor: isImpostor,
                        isCorrect: !isImpostor
                    }
                ]);

                // Orb Text
                orb.add([
                    text(val.toString(), { size: 12, font: "monospace" }),
                    anchor("center"),
                    color(255, 255, 255)
                ]);
            });

            // 4. Assign Portal Values
            // Select one portal to be the Correct one
            const correctPortalId = choose([1, 2, 3]);
            
            objects.portals.forEach(p => {
                let displayVal = 0;
                if (p.portalId === correctPortalId) {
                    displayVal = levelMathState.correctSum;
                    p.isExit = true;
                } else {
                    // Fake values: Sum +/- random amount
                    displayVal = levelMathState.correctSum + choose([-5, -2, 5, 10, 20]);
                    if (displayVal === levelMathState.correctSum) displayVal += 1;
                    p.isExit = false;
                }
                
                p.sumValue = displayVal;
                // Update label
                const label = p.get("portalLabel")[0];
                label.text = `Sum:\n${displayVal}`;
            });

            return { spawnPos };
        }

        // ============================================================
        //  MAIN GAME SCENE
        // ============================================================
        scene("game", (levelIdx = 0) => {
            setGravity(CONFIG.gravity);

            // Build Level
            const { spawnPos } = buildLevel(LEVELS[levelIdx], levelIdx);

            // Game State
            let currentSum = 0;
            let termsCollected = 0;
            let hp = CONFIG.playerHealth;
            let sumStreak = 0; // "Score" streak

            // --- Player Object (Vector) ---
            const player = add([
                rect(24, 32),
                pos(spawnPos),
                area(),
                body(),
                anchor("botleft"),
                color(...CONFIG.playerColor),
                outline(2, rgb(255, 255, 255)),
                z(10),
                "player",
            ]);
            
            // Add 'eyes' to Vector
            player.add([
                rect(18, 6),
                pos(3, 8),
                color(0, 0, 0)
            ]);

            // --- HUD ---
            const hudBg = add([
                rect(width(), 40),
                fixed(),
                color(0, 0, 0, 0.6),
                z(90)
            ]);

            const mathInfoLabel = add([
                text(`a:${levelMathState.a} r:${levelMathState.r}`, { size: 16, font: "monospace" }),
                pos(16, 12),
                fixed(),
                z(100),
                color(255, 255, 100),
            ]);

            const sumLabel = add([
                text(`Sum: 0`, { size: 16, font: "monospace" }),
                pos(200, 12),
                fixed(),
                z(100),
                color(0, 255, 255),
            ]);

            const progressLabel = add([
                text(`Terms: 0/${levelMathState.maxTerms}`, { size: 16, font: "monospace" }),
                pos(400, 12),
                fixed(),
                z(100),
                color(200, 200, 255),
            ]);
            
            const hpLabel = add([
                text(`HP: ${hp}`, { size: 16, font: "monospace" }),
                pos(width() - 100, 12),
                fixed(),
                z(100),
                color(255, 100, 100),
            ]);

            // Controls Hint
            add([
                text("Controls: Arrow Keys / WASD + Space", { size: 12, font: "monospace" }),
                pos(center().x, height() - 20),
                anchor("center"),
                fixed(),
                color(100, 100, 150),
                opacity(0.7)
            ]);

            // --- Movement ---
            onButtonDown("left", () => {
                player.move(-CONFIG.moveSpeed, 0);
            });

            onButtonDown("right", () => {
                player.move(CONFIG.moveSpeed, 0);
            });

            onButtonPress("jump", () => {
                if (player.isGrounded()) {
                    player.jump(CONFIG.jumpForce);
                }
            });

            player.onUpdate(() => {
                if (player.vel && player.vel.y > CONFIG.maxFallSpeed) {
                    player.vel.y = CONFIG.maxFallSpeed;
                }
                
                // Fall death
                if (player.pos.y > 800) {
                    hp--;
                    updateHP();
                    if (hp > 0) respawn();
                }
            });

            // Camera Follow
            if (CONFIG.cameraFollow) {
                player.onUpdate(() => {
                    // REVISION: Use getCamPos() and setCamPos() to avoid deprecation warning
                    const currCam = getCamPos();
                    const targetX = player.pos.x + 100;
                    // Keep camera Y somewhat stable unless player moves drastically
                    const targetY = player.pos.y - 50; 
                    
                    setCamPos(
                        lerp(currCam.x, targetX, 0.05),
                        lerp(currCam.y, targetY, 0.05)
                    );
                });
            }

            // --- Helper Functions ---
            function updateHP() {
                hpLabel.text = `HP: ${hp}`;
                if (hp <= 0) go("gameover", { score: sumStreak, level: levelIdx });
            }
            
            function respawn() {
                player.pos = spawnPos.clone();
                player.vel = vec2(0, 0);
                shake(10);
            }

            // --- Interactions ---

            // 1. Orb Collection
            player.onCollide("orb", (orb) => {
                if (orb.isCorrect) {
                    // Correct Geometric Term
                    currentSum += orb.val;
                    termsCollected++;
                    sumStreak += 10;
                    sumLabel.text = `Sum: ${currentSum}`;
                    progressLabel.text = `Terms: ${termsCollected}/${levelMathState.maxTerms}`;
                    addKaboom(orb.pos);
                    
                    // Floating text
                    add([
                        text("+" + orb.val, { size: 16 }),
                        pos(orb.pos),
                        color(0, 255, 0),
                        move(UP, 100),
                        opacity(1),
                        lifespan(0.5, { fade: 0.5 }),
                        z(100)
                    ]);
                } else {
                    // Arithmetic Impostor
                    hp--;
                    updateHP();
                    
                    // REVISION: Reset Streak to 0 on failure as per GDD
                    sumStreak = 0;
                    
                    shake(10);
                    add([
                        text("IMPOSTOR!", { size: 16 }),
                        pos(orb.pos),
                        color(255, 50, 50),
                        move(UP, 100),
                        opacity(1),
                        lifespan(0.5, { fade: 0.5 }),
                        z(100)
                    ]);
                    // Note: We do NOT reset currentSum or termsCollected, 
                    // otherwise the level becomes unwinnable due to missing parts of the sum.
                }
                destroy(orb);
            });

            // 2. Static Errors (Hazards)
            player.onCollide("hazard", () => {
                hp--;
                updateHP();
                shake(5);
                player.jump(300); // Knockback
                if (hp > 0) {
                    flash(rgb(255, 0, 0), 0.1);
                }
            });

            // 3. Portals
            player.onCollide("portal", (p) => {
                // Check 1: Do we have all terms?
                if (termsCollected < levelMathState.maxTerms) {
                    shake(2);
                    add([
                        text(`Missing Terms!\nNeed ${levelMathState.maxTerms - termsCollected} more`, { size: 14, align: "center" }),
                        pos(p.pos.x, p.pos.y - 40),
                        color(255, 200, 0),
                        move(UP, 50),
                        lifespan(1.5, {fade: 0.5}),
                        opacity(1),
                        z(100)
                    ]);
                    
                    // REVISION: Use velocity for knockback instead of move()
                    player.vel.x = -500;
                    player.jump(200);
                    
                    return;
                }

                // Check 2: Is the sum correct?
                if (p.sumValue === currentSum) {
                    // Success!
                    addKaboom(player.pos);
                    const nextLevel = levelIdx + 1;
                    if (nextLevel < LEVELS.length) {
                        go("game", nextLevel);
                    } else {
                        go("win", { score: sumStreak + currentSum });
                    }
                } else {
                    // Wrong Portal
                    shake(5);
                    add([
                        text("Wrong Sum!", { size: 18 }),
                        pos(p.pos.x, p.pos.y - 40),
                        color(255, 0, 0),
                        move(UP, 50),
                        lifespan(1, {fade: 0.5}),
                        opacity(1),
                        z(100)
                    ]);
                    
                    // REVISION: Use velocity for knockback
                    player.vel.x = -500; 
                    player.jump(200);
                }
            });

            // --- Background FX ---
            // Floating math symbols
            loop(0.5, () => {
                const x = rand(0, width() * 3); // Wide range for parallax
                const y = rand(-200, height() + 200);
                const sym = choose(["+", "×", "÷", "-", "∑"]);
                add([
                    text(sym, { size: rand(10, 40), font: "monospace" }),
                    pos(x, y),
                    color(255, 255, 255),
                    opacity(0.1),
                    move(vec2(rand(-20, 20), rand(-20, 20)), rand(10, 30)),
                    lifespan(5, { fade: 0.5 }),
                    z(-10),
                ]);
            });
        });

        // ============================================================
        //  UI SCENES
        // ============================================================
        scene("gameover", ({ score, level }) => {
            add([
                text("CALCULATION FAILED", { size: 48, font: "monospace" }),
                pos(center()),
                anchor("center"),
                color(255, 50, 80),
            ]);
            add([
                text(`Score: ${score}`, { size: 24, font: "monospace" }),
                pos(center().x, center().y + 60),
                anchor("center"),
                color(255, 255, 255),
            ]);
            add([
                text("Press SPACE to Retry", { size: 18, font: "monospace" }),
                pos(center().x, center().y + 120),
                anchor("center"),
                color(200, 200, 255),
            ]);
            onKeyPress("space", () => go("game", level));
            onClick(() => go("game", level));
        });

        scene("win", ({ score }) => {
            add([
                text("SEQUENCE COMPLETE", { size: 48, font: "monospace" }),
                pos(center()),
                anchor("center"),
                color(0, 255, 255),
            ]);
            add([
                text(`Total Score: ${score}`, { size: 24, font: "monospace" }),
                pos(center().x, center().y + 60),
                anchor("center"),
                color(255, 255, 0),
            ]);
            add([
                text("Press SPACE to Restart", { size: 18, font: "monospace" }),
                pos(center().x, center().y + 120),
                anchor("center"),
                color(200, 200, 255),
            ]);
            onKeyPress("space", () => go("game", 0));
            onClick(() => go("game", 0));
        });

        // Start Game
        go("game", 0);

    </script>
</body>

</html>