<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Chloroplast Command: Photosynthesis Shooter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: sans-serif;
        }

        canvas {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>

<body>
    <!-- KAPLAY CDN -->
    <script src="https://unpkg.com/kaplay@3001.0.19/dist/kaplay.js"></script>
    <script>
        // =============================================
        //  CHLOROPLAST COMMAND — Photosynthesis Shooter
        //  Collect Inputs (Sun, H2O, CO2) to trigger Growth Pulse.
        //  Avoid Outputs (O2, Glucose) to prevent clogging.
        //  Shoot Pollution enemies.
        // =============================================

        // -- CONFIG: Gameplay Constants --
        const C = {
            playerSpeed: 280,
            bulletSpeed: 600,
            fireRate: 0.12,
            playerHP: 5,
            spawnRate: 1.2,       // Enemy spawn rate
            moleculeSpawnRate: 1.5, // Ingredient spawn rate
            enemySpeed: [80, 200],
            enemyHP: [1, 3],
            enemyFireRate: 1.5,
            enemyBulletSpd: 250,
            // Visual Palette
            bg: [10, 35, 15],             // Deep Forest Green
            playerCol: [50, 200, 50],     // Chloroplast Green
            bulletCol: [200, 255, 0],     // Bright Lime Energy
            enemyBulletCol: [180, 0, 255],// Toxic Purple
            cloggedCol: [150, 150, 150],  // Greyed out (clogged state)
        };

        // -- INIT --
        kaplay({ 
            width: 480, 
            height: 700, 
            background: C.bg, 
            crisp: true, 
            letterbox: true 
        });
        
        loadBean(); // Base sprite for player

        // -- CELL FLOW: Decorative background (Cytoplasm) --
        function makeCellFlow() {
            for (let i = 0; i < 60; i++) {
                const s = rand(2, 5);
                add([
                    rect(s, s), // Square "debris"
                    pos(rand(0, width()), rand(0, height())),
                    color(120, 200, 100),
                    opacity(rand(0.1, 0.3)),
                    z(-10),
                    move(DOWN, rand(20, 80)),
                    offscreen({ destroy: false }),
                    "debris",
                ]);
            }
            onUpdate("debris", (s) => {
                if (s.pos.y > height() + 10) {
                    s.pos.y = -10;
                    s.pos.x = rand(0, width());
                }
            });
        }

        // ==================
        //  GAME SCENE
        // ==================
        scene("game", () => {
            makeCellFlow();
            
            // Game State
            let score = 0;
            let fireTimer = 0;
            let gameOver = false;
            let spawnTimer = 0;
            let molTimer = 0;
            let difficulty = 1;

            // Recipe State (The Addon Mechanic)
            let recipe = { sun: false, water: false, co2: false };

            // -- PLAYER: Super Chloroplast --
            const player = add([
                sprite("bean"),
                pos(width() / 2, height() - 80),
                area(),
                anchor("center"),
                scale(1.5), // Larger, sturdy organelle
                color(...C.playerCol),
                z(10),
                timer(), // Required for local tween/wait
                { 
                    hp: C.playerHP, 
                    invuln: 0,
                    clogged: 0 // If > 0, cannot shoot (penalty)
                },
                "player",
            ]);

            // -- HUD --
            // Score
            const scoreTxt = add([
                text("0", { size: 22 }),
                pos(width() / 2, 14), anchor("top"), color(255, 220, 80), fixed(), z(50),
            ]);
            
            // Health (Leaf Hearts)
            const hpTxt = add([
                text("", { size: 20 }),
                pos(16, 14), color(150, 255, 150), fixed(), z(50),
            ]);

            // -- RECIPE METER UI (Top Right) --
            // Background box for meter
            add([
                rect(110, 40, { radius: 4 }),
                pos(width() - 120, 10),
                color(0, 0, 0),
                opacity(0.5),
                fixed(),
                z(45)
            ]);
            add([
                text("RECIPE", { size: 10 }),
                pos(width() - 65, 12),
                anchor("top"),
                color(200, 255, 200),
                fixed(),
                z(50)
            ]);
            
            // Icons
            const iconY = 32;
            const sunIcon = add([
                circle(6), pos(width() - 95, iconY), color(255, 255, 0), fixed(), z(50), opacity(0.2)
            ]);
            const waterIcon = add([
                circle(6), pos(width() - 65, iconY), color(0, 150, 255), fixed(), z(50), opacity(0.2)
            ]);
            const co2Icon = add([
                circle(6), pos(width() - 35, iconY), color(150, 150, 150), fixed(), z(50), opacity(0.2)
            ]);

            // HUD Update Loop
            function updateHUD() {
                scoreTxt.text = `${score}`;
                // Leaf symbols for HP
                let hearts = "";
                for (let i = 0; i < player.hp; i++) hearts += "☘ ";
                hpTxt.text = hearts.trim();

                // Update Recipe Icons
                sunIcon.opacity = recipe.sun ? 1 : 0.2;
                waterIcon.opacity = recipe.water ? 1 : 0.2;
                co2Icon.opacity = recipe.co2 ? 1 : 0.2;
            }
            updateHUD();

            // -- MOVEMENT --
            const moveSpeed = C.playerSpeed;
            onKeyDown("left", () => { if (!gameOver) player.move(-moveSpeed, 0); });
            onKeyDown("right", () => { if (!gameOver) player.move(moveSpeed, 0); });
            onKeyDown("up", () => { if (!gameOver) player.move(0, -moveSpeed); });
            onKeyDown("down", () => { if (!gameOver) player.move(0, moveSpeed); });
            onKeyDown("a", () => { if (!gameOver) player.move(-moveSpeed, 0); });
            onKeyDown("d", () => { if (!gameOver) player.move(moveSpeed, 0); });
            onKeyDown("w", () => { if (!gameOver) player.move(0, -moveSpeed); });
            onKeyDown("s", () => { if (!gameOver) player.move(0, moveSpeed); });

            // Player Logic Loop
            player.onUpdate(() => {
                // Clamp position
                player.pos.x = clamp(player.pos.x, 20, width() - 20);
                player.pos.y = clamp(player.pos.y, 40, height() - 20);
                
                // Invulnerability flicker
                if (player.invuln > 0) {
                    player.invuln -= dt();
                    player.opacity = wave(0.3, 1, time() * 16);
                } else {
                    player.opacity = 1;
                }

                // Clogged State (Penalty) handling
                if (player.clogged > 0) {
                    player.clogged -= dt();
                    player.color = rgb(...C.cloggedCol); // Turn grey when clogged
                } else {
                    player.color = rgb(...C.playerCol); // Return to green
                }
            });

            // -- SHOOTING --
            onUpdate(() => {
                if (gameOver) return;
                fireTimer -= dt();
                const shooting = isKeyDown("z") || isKeyDown("space");
                
                // Can only shoot if not clogged!
                if (shooting && fireTimer <= 0 && player.clogged <= 0) {
                    fireTimer = C.fireRate;
                    for (const ox of [-10, 10]) {
                        add([
                            rect(4, 14, { radius: 2 }),
                            pos(player.pos.x + ox, player.pos.y - 20),
                            area(),
                            anchor("center"),
                            color(...C.bulletCol),
                            move(UP, C.bulletSpeed),
                            offscreen({ destroy: true }),
                            z(8),
                            "pbullet",
                        ]);
                    }
                }
            });

            // -- ENEMY SPAWNING (Pollution) --
            function spawnEnemy() {
                if (gameOver) return;
                const type = choose(["basic", "basic", "fast", "tank"]);
                const conf = {
                    basic: { w: 26, h: 26, hp: 1, spd: rand(...C.enemySpeed), col: [100, 100, 100], pts: 100, shoots: false, name: "Smog" },
                    fast:  { w: 20, h: 20, hp: 1, spd: rand(180, 300), col: [200, 50, 50], pts: 150, shoots: false, name: "Pest" },
                    tank:  { w: 40, h: 40, hp: 3, spd: rand(50, 100), col: [40, 40, 40], pts: 300, shoots: true, name: "Soot" },
                }[type];

                const e = add([
                    rect(conf.w, conf.h, { radius: 4 }),
                    pos(rand(30, width() - 30), -40),
                    area(),
                    anchor("center"),
                    color(...conf.col),
                    outline(2, rgb(0, 0, 0)),
                    z(9),
                    { hp: conf.hp, pts: conf.pts, shoots: conf.shoots, fireCD: rand(1, C.enemyFireRate) },
                    "enemy",
                ]);

                // Movement patterns
                if (type === "fast") {
                    e.onUpdate(() => {
                        e.move(Math.sin(time() * 4 + e.pos.x) * 120, conf.spd);
                    });
                } else {
                    e.onUpdate(() => { e.move(0, conf.spd); });
                }

                // Enemy Shooting (Toxins)
                if (conf.shoots) {
                    e.onUpdate(() => {
                        if (gameOver) return;
                        e.fireCD -= dt();
                        if (e.fireCD <= 0) {
                            e.fireCD = C.enemyFireRate;
                            add([
                                circle(5),
                                pos(e.pos),
                                area({ shape: new Rect(vec2(-5, -5), 10, 10) }),
                                anchor("center"),
                                color(...C.enemyBulletCol),
                                move(DOWN, C.enemyBulletSpd),
                                offscreen({ destroy: true }),
                                z(8),
                                "ebullet",
                            ]);
                        }
                    });
                }
            }

            // -- MOLECULE SPAWNING (Inputs/Outputs) --
            function spawnMolecule() {
                if (gameOver) return;
                // 60% chance for Input (Good), 40% for Output (Bad)
                const isInput = rand() < 0.6;
                
                let mType, mCol, mShape;
                if (isInput) {
                    const choice = choose(["sun", "water", "co2"]);
                    if (choice === "sun") { mCol = [255, 255, 0]; mType = "sun"; }
                    else if (choice === "water") { mCol = [0, 150, 255]; mType = "water"; }
                    else { mCol = [150, 150, 150]; mType = "co2"; }
                } else {
                    const choice = choose(["oxygen", "glucose"]);
                    mType = choice;
                }

                // Components base
                const comps = [
                    pos(rand(20, width() - 20), -20),
                    area(),
                    anchor("center"),
                    move(DOWN, rand(100, 150)), // Fall speed
                    offscreen({ destroy: true }),
                    z(20),
                    { type: mType, isInput: isInput }
                ];

                // Shape/Color logic
                if (mType === "sun" || mType === "water" || mType === "co2") {
                    // Inputs are solid circles
                    comps.push(circle(12));
                    comps.push(color(...mCol));
                    comps.push("input"); // tag
                } else if (mType === "oxygen") {
                    // Oxygen is a bubble (white outline)
                    comps.push(circle(12));
                    comps.push(color(0,0,0,0)); // transparent fill
                    comps.push(outline(2, rgb(255, 255, 255)));
                    comps.push("output"); // tag
                } else if (mType === "glucose") {
                    // Glucose is a hexagon/rect (orange)
                    comps.push(rect(16, 16, { radius: 2 }));
                    comps.push(color(255, 150, 0));
                    comps.push("output"); // tag
                }

                add(comps);
            }

            // -- RECIPE CHECK & PULSE LOGIC --
            function checkRecipe() {
                updateHUD();
                
                // If all ingredients collected
                if (recipe.sun && recipe.water && recipe.co2) {
                    // Reset recipe
                    recipe.sun = false;
                    recipe.water = false;
                    recipe.co2 = false;
                    updateHUD();

                    // Trigger Growth Pulse
                    score += 500;
                    shake(10);
                    
                    // Create visual pulse
                    const pulse = add([
                        circle(10),
                        pos(player.pos),
                        area(),
                        anchor("center"),
                        color(255, 255, 255),
                        opacity(0.8),
                        timer(),
                        z(100),
                        "pulse"
                    ]);

                    // Animate pulse expansion
                    pulse.tween(10, 800, 0.6, (v) => pulse.radius = v, easings.easeOutExpo);
                    pulse.tween(0.8, 0, 0.6, (v) => pulse.opacity = v, easings.linear);
                    pulse.wait(0.6, () => destroy(pulse));
                }
            }

            // -- COLLISIONS --

            // 1. Player collects Input
            onCollide("player", "input", (p, i) => {
                destroy(i);
                // "Ding" effect (visual only here, could add sound)
                add([
                    text("+"+i.type.toUpperCase(), { size: 12 }),
                    pos(p.pos.x, p.pos.y - 30),
                    color(255, 255, 255),
                    move(UP, 50),
                    opacity(1),
                    lifespan(0.5, { fade: 0.5 }),
                    anchor("center"),
                    z(60)
                ]);

                // Update state
                if (i.type === "sun") {
                    if (recipe.sun) score += 50; // Bonus for duplicate
                    recipe.sun = true;
                } else if (i.type === "water") {
                    if (recipe.water) score += 50;
                    recipe.water = true;
                } else if (i.type === "co2") {
                    if (recipe.co2) score += 50;
                    recipe.co2 = true;
                }
                
                checkRecipe();
            });

            // 2. Player hits Output (Hazard) -> Clog
            onCollide("player", "output", (p, o) => {
                destroy(o);
                shake(2);
                
                // Penalty text
                add([
                    text("CLOGGED!", { size: 14 }),
                    pos(p.pos.x, p.pos.y - 40),
                    color(255, 100, 100),
                    move(UP, 20),
                    lifespan(0.8),
                    anchor("center"),
                    z(60)
                ]);

                // Apply penalty
                p.clogged = 1.0; // 1 second no shooting
            });

            // 3. Pulse clears Enemies
            onCollide("pulse", "enemy", (p, e) => {
                addKaboom(e.pos);
                destroy(e);
                score += 500; // Big points for pulse kills
                updateHUD();
            });
            // Pulse also clears enemy bullets
            onCollide("pulse", "ebullet", (p, b) => destroy(b));


            // 4. Standard Combat Collisions
            onCollide("pbullet", "enemy", (b, e) => {
                destroy(b);
                e.hp--;
                if (e.hp <= 0) {
                    score += e.pts;
                    addKaboom(e.pos);
                    destroy(e);
                    updateHUD();
                }
            });

            onCollide("ebullet", "player", (b) => {
                destroy(b);
                hurtPlayer();
            });

            onCollide("enemy", "player", (e) => {
                score += e.pts;
                addKaboom(e.pos);
                destroy(e);
                hurtPlayer();
                updateHUD();
            });

            // -- DIFFICULTY & LOOP --
            onUpdate(() => {
                if (gameOver) return;
                
                // Scale difficulty
                difficulty = 1 + score / 2000;
                
                // Spawn Enemies
                spawnTimer -= dt();
                if (spawnTimer <= 0) {
                    spawnTimer = C.spawnRate / difficulty;
                    spawnEnemy();
                }

                // Spawn Molecules (Inputs/Outputs)
                molTimer -= dt();
                if (molTimer <= 0) {
                    // Molecules spawn slightly faster as difficulty rises
                    molTimer = C.moleculeSpawnRate / (difficulty * 0.8); 
                    spawnMolecule();
                }
            });

            // -- PLAYER DAMAGE --
            function hurtPlayer() {
                if (player.invuln > 0 || gameOver) return;
                player.hp--;
                player.invuln = 1.5;
                shake(8);
                updateHUD();
                if (player.hp <= 0) {
                    gameOver = true;
                    addKaboom(player.pos);
                    player.opacity = 0;
                    wait(1, () => go("gameover", score));
                }
            }

            // Cleanup falling enemies/items
            onUpdate("enemy", (e) => { if (e.pos.y > height() + 60) destroy(e); });
            
            // Tutorial Text
            add([
                text("WASD: Move | Z/SPACE: Shoot", { size: 12 }),
                pos(width() / 2, height() - 25), anchor("bot"),
                color(120, 200, 120), fixed(), z(50),
            ]);
            add([
                text("Collect: Sun/Water/CO2 | Avoid: O2/Glucose", { size: 10 }),
                pos(width() / 2, height() - 10), anchor("bot"),
                color(180, 255, 180), fixed(), z(50),
            ]);
        });

        // ==================
        //  GAME OVER SCENE
        // ==================
        scene("gameover", (finalScore) => {
            makeCellFlow();
            add([text("CELL DEFEATED", { size: 36 }), pos(center()), anchor("center"), color(220, 60, 80)]);
            add([text(`Score: ${finalScore}`, { size: 26 }), pos(center().x, center().y + 50), anchor("center"), color(255, 220, 80)]);
            add([text("Photosynthesis Halted", { size: 16 }), pos(center().x, center().y + 85), anchor("center"), color(150, 150, 150)]);
            add([text("Press SPACE to retry", { size: 15 }), pos(center().x, center().y + 120), anchor("center"), color(140, 140, 170)]);
            onKeyPress("space", () => go("game"));
            onClick(() => go("game"));
        });

        // Start
        go("game");
    </script>
</body>

</html>