<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Historical Messenger: Civil War Causes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #2b2b2b;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }

        canvas {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>

<body>
    <!-- 
    LESSON OBJECTIVE: Identify the primary causes of the American Civil War.
    
    GAME MECHANICS:
    1. Exploration: Player navigates a 19th-century environment.
    2. Discrimination: Player must distinguish between valid historical causes (Slavery, States' Rights, Economics) 
       and anachronistic distractors.
    3. Gatekeeping: Progress is blocked until mastery (3 correct causes) is demonstrated.
    
    FIXES APPLIED:
    - Implemented "Deck System" for scrolls to guarantee at least 3 valid causes per level (Preventing Soft-Lock).
    - Updated Camera API to use setCamPos() and getCamPos().
    -->

    <script src="https://unpkg.com/kaplay@3001/dist/kaplay.js"></script>
    <script>
        // ============================================================
        //  THE HISTORICAL MESSENGER
        //  A Kaplay.js educational platformer about Civil War causes.
        // ============================================================

        // ----- 1. GAME DATA & CONFIG -----
        
        const VALID_CAUSES = ["Slavery", "States' Rights", "Economics", "Sectionalism", "Election 1860"];
        const DISTRACTORS = ["Space Travel", "The Internet", "Robots", "Aliens", "Television", "Smartphones"];

        const CONFIG = {
            // Physics
            gravity: 1600,
            jumpForce: 680,
            moveSpeed: 320,
            maxFallSpeed: 900,

            // Player
            playerStartPos: { x: 50, y: 0 },
            playerHealth: 3,

            // Camera
            cameraFollow: true,

            // Visuals (Sepia / Parchment Theme)
            bgColor: [225, 205, 170],      // Parchment Tan
            floorColor: [101, 67, 33],     // Dark Wood/Soil
            platformColor: [160, 130, 90], // Weathered Wood
            hazardColor: [139, 69, 19],    // Tumbleweed Brown
            scrollColor: [255, 250, 240],  // Off-white Paper
            portalLockedColor: [100, 100, 100], // Gray (Locked)
            portalOpenColor: [50, 50, 180],     // Blue (Open)
            textColor: [40, 30, 20],       // Ink Black
        };

        // Levels
        const LEVELS = [
            // --- Level 1 ---
            [
                "                                        ",
                "                                        ",
                "                                        ",
                "                         $   $          ",
                "                        ------          ",
                "            $  $                        ",
                "           ------           $  $        ",
                "                           ------    >  ",
                "    $  $                          ====  ",
                "   ------                        -      ",
                "                   $                    ",
                "  @              =====     ===          ",
                "========   ^^^  ========  ======  ======",
            ],
            // --- Level 2 ---
            [
                "                                        ",
                "                                   >    ",
                "                                  ===   ",
                "                       $  $             ",
                "                      ------            ",
                "           $                   $        ",
                "          ---              ------       ",
                "                                        ",
                "    $         $     $                   ",
                "   ---    ------  -----                 ",
                "                                        ",
                "  @                          ===        ",
                "=====  ^^^  ====  ^^^  ====  ^^^^^^  ===",
            ],
        ];

        // ----- 2. INITIALIZE KAPLAY -----
        kaplay({
            background: CONFIG.bgColor,
            width: 800,
            height: 480,
            scale: 1,
            crisp: true,
            global: true,
            letterbox: true,
            buttons: {
                jump: { keyboard: ["space", "w", "up"], gamepad: ["south"] },
                left: { keyboard: ["a", "left"], gamepad: ["dpad-left"] },
                right: { keyboard: ["d", "right"], gamepad: ["dpad-right"] },
            },
        });

        const TILE = 32;

        // ----- 3. HELPER FUNCTIONS -----

        // Build Level Function
        function buildLevel(mapData) {
            const objects = { portals: [] };
            let spawnPos = vec2(CONFIG.playerStartPos.x, CONFIG.playerStartPos.y);

            // --- STEP 1: PRE-CALCULATE SCROLLS (Fix Soft-Lock) ---
            // Count total slots for scrolls in this map
            let scrollSlots = 0;
            for (const row of mapData) {
                for (const char of row) {
                    if (char === '$') scrollSlots++;
                }
            }

            // Create a "deck" of scroll contents to ensure solvability
            let scrollDeck = [];
            const requiredValid = 3; 

            // 1. Add guaranteed valid causes
            // Shuffle the master list of valid causes to pick random ones
            const shuffledValids = [...VALID_CAUSES].sort(() => 0.5 - Math.random());
            
            for (let i = 0; i < requiredValid; i++) {
                // Use modulo in case requiredValid > VALID_CAUSES.length (unlikely here)
                scrollDeck.push({
                    text: shuffledValids[i % shuffledValids.length],
                    isValid: true
                });
            }

            // 2. Fill the remaining slots with random items (biased towards distractors)
            const remainingSlots = Math.max(0, scrollSlots - requiredValid);
            for (let i = 0; i < remainingSlots; i++) {
                const isDistractor = Math.random() < 0.6; // 60% chance for distractor
                if (isDistractor) {
                    scrollDeck.push({ text: choose(DISTRACTORS), isValid: false });
                } else {
                    scrollDeck.push({ text: choose(VALID_CAUSES), isValid: true });
                }
            }

            // 3. Shuffle the deck so the valid ones aren't always the first ones found
            scrollDeck.sort(() => 0.5 - Math.random());
            
            let scrollIndex = 0;

            // --- STEP 2: BUILD MAP ---
            for (let row = 0; row < mapData.length; row++) {
                for (let col = 0; col < mapData[row].length; col++) {
                    const ch = mapData[row][col];
                    const x = col * TILE;
                    const y = row * TILE;

                    switch (ch) {
                        // Ground
                        case "=":
                            add([
                                rect(TILE, TILE),
                                pos(x, y),
                                area(),
                                body({ isStatic: true }),
                                color(...CONFIG.floorColor),
                                outline(2, rgb(30, 20, 10)),
                                "ground",
                            ]);
                            break;

                        // Platform
                        case "-":
                            add([
                                rect(TILE, TILE / 2),
                                pos(x, y + TILE / 2),
                                area(),
                                body({ isStatic: true }),
                                color(...CONFIG.platformColor),
                                outline(2, rgb(50, 40, 30)),
                                "platform",
                            ]);
                            break;

                        // Player Spawn
                        case "@":
                            spawnPos = vec2(x, y);
                            break;

                        // Scrolls (Replaces Coins)
                        case "$":
                            // Pop data from our pre-calculated guaranteed deck
                            const data = scrollDeck[scrollIndex] || { text: "Error", isValid: false };
                            scrollIndex++;

                            const scroll = add([
                                rect(24, 30),
                                pos(x + TILE/2, y + TILE/2),
                                anchor("center"),
                                area(),
                                color(...CONFIG.scrollColor),
                                outline(1, rgb(0,0,0)),
                                "scroll",
                                {
                                    causeText: data.text,
                                    isValid: data.isValid,
                                    bobOffset: rand(0, 10)
                                }
                            ]);
                            
                            // Floating Label
                            scroll.add([
                                text(data.text, { size: 10, width: 100, align: "center" }),
                                pos(0, -25),
                                anchor("center"),
                                color(0, 0, 0),
                            ]);
                            break;

                        // Hazards
                        case "^":
                            add([
                                circle(12),
                                pos(x + TILE/2, y + TILE/2),
                                anchor("center"),
                                // Square hitbox for consistent collision
                                area({ shape: new Rect(vec2(-10, -10), 20, 20) }),
                                color(...CONFIG.hazardColor),
                                outline(2, rgb(80, 40, 10)),
                                "hazard",
                                { rotSpeed: rand(2, 5) }
                            ]);
                            break;

                        // Portal
                        case ">":
                            const portal = add([
                                rect(TILE * 1.2, TILE * 2),
                                pos(x, y - TILE),
                                area(),
                                anchor("top"),
                                color(...CONFIG.portalLockedColor),
                                outline(4, rgb(50, 50, 50)),
                                z(1),
                                "portal",
                                { isOpen: false }
                            ]);
                            
                            // Knob
                            portal.add([
                                circle(4),
                                pos(TILE/2, TILE),
                                color(200, 200, 0)
                            ]);
                            
                            objects.portals.push(portal);
                            break;
                    }
                }
            }

            return { spawnPos, objects };
        }

        // ----- 4. MAIN GAME SCENE -----
        scene("game", (levelIdx = 0) => {
            setGravity(CONFIG.gravity);

            // Level State
            let score = 0;
            let hp = CONFIG.playerHealth;
            let collectedCauses = [];
            
            const { spawnPos, objects } = buildLevel(LEVELS[levelIdx]);

            // --- Player ---
            const player = add([
                rect(24, 32),
                pos(spawnPos),
                area(),
                body(),
                anchor("botleft"),
                color(40, 40, 40),
                outline(1, rgb(0,0,0)),
                z(10),
                { 
                    speedMultiplier: 1.0,
                    facing: 1
                },
                "player",
            ]);

            // --- HUD ---
            const hpLabel = add([
                text(`Integrity: ${hp}`, { size: 16, font: "monospace" }),
                pos(16, 12),
                fixed(),
                z(100),
                color(...CONFIG.textColor),
            ]);

            const listHeader = add([
                text("Causes Found:", { size: 16, font: "monospace" }),
                pos(16, 40),
                fixed(),
                z(100),
                color(...CONFIG.textColor),
            ]);

            const listContent = add([
                text("- (need 3)", { size: 14, width: 200, font: "monospace" }),
                pos(16, 60),
                fixed(),
                z(100),
                color(80, 60, 40),
            ]);

            // Controls Info
            add([
                text("(A/D) Move  (SPACE) Jump", { size: 14, font: "monospace" }),
                pos(center().x, 12),
                anchor("top"),
                fixed(),
                z(100),
                color(...CONFIG.textColor),
                opacity(0.7)
            ]);

            add([
                text(`Level ${levelIdx + 1}`, { size: 18, font: "monospace" }),
                pos(width() - 16, 12),
                anchor("topright"),
                fixed(),
                z(100),
                color(...CONFIG.textColor),
            ]);

            // --- Logic Updates ---

            // Check win condition to open portals
            onUpdate(() => {
                if (collectedCauses.length >= 3) {
                    objects.portals.forEach(p => {
                        if (!p.isOpen) {
                            p.isOpen = true;
                            p.color = rgb(...CONFIG.portalOpenColor);
                            p.use(opacity(0.8));
                            p.add([
                                text("OPEN", { size: 12 }),
                                pos(TILE * 0.6, -10),
                                anchor("center"),
                                color(0, 0, 0)
                            ]);
                        }
                    });
                }
            });

            // Rotate Tumbleweeds
            onUpdate("hazard", (h) => {
                h.angle += h.rotSpeed;
            });

            // Bob Scrolls
            onUpdate("scroll", (s) => {
                s.pos.y += Math.sin(time() * 4 + s.bobOffset) * 0.5;
            });

            // --- Input ---
            onButtonDown("left", () => {
                player.move(-CONFIG.moveSpeed * player.speedMultiplier, 0);
                player.facing = -1;
            });

            onButtonDown("right", () => {
                player.move(CONFIG.moveSpeed * player.speedMultiplier, 0);
                player.facing = 1;
            });

            onButtonPress("jump", () => {
                if (player.isGrounded()) {
                    player.jump(CONFIG.jumpForce);
                }
            });

            // Cap fall speed
            player.onUpdate(() => {
                if (player.vel.y > CONFIG.maxFallSpeed) player.vel.y = CONFIG.maxFallSpeed;
            });

            // --- Camera Follow ---
            if (CONFIG.cameraFollow) {
                player.onUpdate(() => {
                    // Smoothly interpolate camera position towards player
                    const currentCam = getCamPos(); // Using new getter
                    const targetX = player.pos.x + 100;
                    const targetY = player.pos.y - 50;
                    const targetPos = vec2(targetX, targetY);
                    
                    // Lerp vector for smoothness
                    const newPos = currentCam.lerp(targetPos, 0.05);
                    
                    setCamPos(newPos); // Using new setter
                });
            }

            // --- Interactions ---

            // 1. Collect Scrolls
            player.onCollide("scroll", (scroll) => {
                destroy(scroll);
                
                if (scroll.isValid) {
                    // Correct Cause
                    if (!collectedCauses.includes(scroll.causeText)) {
                        collectedCauses.push(scroll.causeText);
                        score += 100;
                        
                        // Update HUD
                        listContent.text = collectedCauses.map(c => `> ${c}`).join("\n");
                        
                        // Feedback
                        add([
                            text("CORRECT!", { size: 20 }),
                            pos(player.pos.sub(0, 40)),
                            color(0, 150, 0),
                            move(0, -50),
                            lifespan(1, { fade: 0.5 }), 
                            opacity(1)
                        ]);
                    }
                } else {
                    // Distractor / Wrong Cause
                    hp--;
                    hpLabel.text = `Integrity: ${hp}`;
                    shake(5);
                    
                    // Slowdown Penalty
                    player.speedMultiplier = 0.4;
                    wait(2, () => player.speedMultiplier = 1.0); // Recover speed after 2s

                    // Feedback
                    add([
                        text("WRONG! (Slowed)", { size: 20 }),
                        pos(player.pos.sub(0, 40)),
                        color(200, 0, 0),
                        move(0, -50),
                        lifespan(1, { fade: 0.5 }),
                        opacity(1)
                    ]);

                    if (hp <= 0) go("gameover", { score, level: levelIdx, reason: "Misinformation Overload" });
                }
            });

            // 2. Hazards
            player.onCollide("hazard", () => {
                hp--;
                hpLabel.text = `Integrity: ${hp}`;
                flash(rgb(...CONFIG.hazardColor), 0.15);
                shake(10);
                player.jump(300);
                
                if (hp <= 0) {
                    go("gameover", { score, level: levelIdx, reason: "Hit by Tumbleweed" });
                }
            });

            // 3. Portal / Exit
            player.onCollide("portal", (portal) => {
                if (portal.isOpen) {
                    const nextLevel = levelIdx + 1;
                    if (nextLevel < LEVELS.length) {
                        go("game", nextLevel);
                    } else {
                        go("win", { score });
                    }
                } else {
                    shake(2);
                    add([
                        text("Need 3 Valid Causes!", { size: 18 }),
                        pos(player.pos.sub(0, 60)),
                        color(0, 0, 0),
                        move(0, -20),
                        lifespan(1, { fade: 0.5 }),
                        opacity(1)
                    ]);
                }
            });

            // 4. Fall Death
            player.onUpdate(() => {
                if (player.pos.y > LEVELS[levelIdx].length * TILE + 300) {
                    go("gameover", { score, level: levelIdx, reason: "Lost in Time" });
                }
            });
        });

        // ----- 5. GAME OVER SCENE -----
        scene("gameover", ({ score, level, reason }) => {
            add([
                text("GAME OVER", { size: 48, font: "monospace" }),
                pos(center()),
                anchor("center"),
                color(139, 69, 19),
            ]);

            add([
                text(reason, { size: 24 }),
                pos(center().x, center().y + 50),
                anchor("center"),
                color(200, 50, 50),
            ]);

            add([
                text("Press SPACE to try again", { size: 18 }),
                pos(center().x, center().y + 100),
                anchor("center"),
                color(80, 80, 80),
            ]);

            onKeyPress("space", () => go("game", level));
            onClick(() => go("game", level));
        });

        // ----- 6. WIN SCENE -----
        scene("win", ({ score }) => {
            add([
                text("HISTORY PRESERVED!", { size: 40, font: "monospace" }),
                pos(center()),
                anchor("center"),
                color(50, 150, 50),
            ]);

            add([
                text(`Score: ${score}`, { size: 24 }),
                pos(center().x, center().y + 60),
                anchor("center"),
                color(0, 0, 0),
            ]);

            add([
                text("You identified the true causes of the Civil War.", { size: 16 }),
                pos(center().x, center().y + 90),
                anchor("center"),
                color(80, 80, 80),
            ]);

            add([
                text("Press SPACE to play again", { size: 18 }),
                pos(center().x, center().y + 130),
                anchor("center"),
                color(100, 100, 100),
            ]);

            onKeyPress("space", () => go("game", 0));
            onClick(() => go("game", 0));
        });

        // Start
        go("game", 0);

    </script>
</body>

</html>