<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Photosynthesis Maze: Sunny's Quest</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            background: #051a05; /* Deep Green Cytoplasm match */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            display: block;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }
    </style>
</head>

<body>
    <!-- 
      GAME DESIGN: Photosynthesis Maze
      
      OBJECTIVE:
      Help Sunny the Seedling grow by collecting Nutrient Pellets (dots) and synthesizing Glucose.
      
      MECHANICS:
      1. Movement: Arrow keys / WASD to navigate the Cell structures.
      2. Nutrients: Collect small green pellets for basic growth (score).
      3. ADDON - Formula Bar: Collect Water (Blue), Sunlight (Yellow), and CO2 (Grey) to trigger Photosynthesis.
         - Collecting all three triggers an "Oxygen Blast" (Power Mode).
      4. Enemies: Avoid Pollution Clouds and Thirsty Aphids.
         - During "Oxygen Blast", enemies turn into raw Glucose (edible).
      
      VISUALS:
      - Player: Green Seedling
      - Walls: Plant Cell Walls
      - Power-up: Defined by the Formula Bar (Water + Sun + CO2)
    -->

    <script src="https://unpkg.com/kaplay@3001.0.0/dist/kaplay.js"></script>
    <script>
        // =============================================
        //  PHOTOSYNTHESIS MAZE GAME
        // =============================================

        // -- CONFIG --
        const C = {
            tile: 32,
            topBar: 40,            // Height of the Formula Bar area
            bottomBar: 40,         // Height of the Stats area
            playerSpeed: 160,
            ghostSpeed: 100,
            ghostCount: 3,
            powerUpTime: 10,       // Duration of Oxygen Blast
            
            // Colors
            bg: [10, 40, 10],              // Cytoplasm (Deep Green)
            wallCol: [20, 80, 20],         // Cell Wall (Dark Forest Green)
            wallOutline: [40, 120, 40],
            dotCol: [200, 255, 200],       // Nutrient Pellets (Light Green)
            chlorophyllCol: [0, 200, 0],   // Chlorophyll (Bonus Points)
            playerCol: [100, 255, 100],    // Sunny the Seedling (Lime Green)
            
            // Ghost Colors: Muddy Grey (Pollution) and Deep Red (Aphids)
            ghostCols: [
                [120, 120, 120], // Pollution Cloud
                [180, 40, 40],   // Thirsty Aphid
                [100, 100, 110], // Pollution Cloud
                [200, 20, 20]    // Thirsty Aphid
            ],
            glucoseCol: [255, 255, 255],   // Scared/Glucose State (White/Crystal)
            
            // Formula Item Colors
            waterCol: [0, 100, 255],       // Water
            sunCol: [255, 255, 0],         // Sunlight
            co2Col: [180, 180, 180],       // CO2
        };

        // -- MAZE LAYOUT --
        // Key:
        // # = Wall
        // . = Nutrient Pellet (Dot)
        // o = Chlorophyll (Bonus Points, NOT powerup)
        // W = Water Drop
        // S = Sunlight Spark
        // C = CO2 Bubble
        // @ = Player Spawn
        // G = Enemy Spawn
        const MAZES = [
            [
                "#####################",
                "#W........#........S#",
                "#.###.###.#.###.###.#",
                "#o#...#.......#...#o#",
                "#.#.#.#.#####.#.#.#.#",
                "#...#..C..#..C..#...#",
                "###.#####.#.#####.###",
                "#.........G.........#",
                "#.###.#.#####.#.###.#",
                "#.#...#...#...#...#.#",
                "#.#.#####.#.#####.#.#",
                "#o..#..S.....W..#..o#",
                "#.###.#.#####.#.###.#",
                "#.....#...@...#.....#",
                "#####################",
            ],
        ];

        const T = C.tile;
        const mapW = MAZES[0][0].length;
        const mapH = MAZES[0].length;

        // Initialize Kaplay
        kaplay({
            width: mapW * T,
            height: mapH * T + C.topBar + C.bottomBar,
            background: C.bg,
            crisp: true,
            letterbox: true,
        });
        loadBean(); // Keeps default assets just in case, but we use primitives

        // ==================
        //  GAME SCENE
        // ==================
        scene("game", (levelIdx = 0) => {
            const maze = MAZES[levelIdx];
            
            // Game State
            let score = 0;
            let totalDots = 0;   // Count of all collectables to determine win
            let collected = 0;
            let lives = 3;
            let powered = false; // "Oxygen Blast" active
            let powerTimer = 0;
            let gameOver = false;
            
            // Photosynthesis Formula State
            // We track which ingredients are currently held in the "Formula Bar"
            let formula = { water: false, sun: false, co2: false };

            let playerSpawn = vec2(1, 1);
            const ghostSpawns = [];
            const offsetY = C.topBar; // Shift maze down for UI

            // -- MAZE BUILDER --
            for (let row = 0; row < maze.length; row++) {
                for (let col = 0; col < maze[row].length; col++) {
                    const ch = maze[row][col];
                    const x = col * T;
                    const y = row * T + offsetY;

                    // Common Wall/Floor Logic
                    if (ch === "#") {
                        add([
                            rect(T, T),
                            pos(x, y),
                            color(...C.wallCol),
                            area(),
                            "wall",
                        ]);
                        continue; // Wall done
                    }

                    // For all other tiles, we might spawn an item or an entity
                    const centerX = x + T / 2;
                    const centerY = y + T / 2;

                    switch (ch) {
                        case ".":
                            totalDots++;
                            add([
                                circle(3),
                                pos(centerX, centerY),
                                anchor("center"),
                                color(...C.dotCol),
                                area({ shape: new Rect(vec2(-4, -4), 8, 8) }),
                                "dot",
                            ]);
                            break;
                        case "o":
                            // Chlorophyll: Bonus points (visuals only, no powerup)
                            totalDots++;
                            const chloro = add([
                                rect(10, 10),
                                pos(centerX, centerY),
                                anchor("center"),
                                color(...C.chlorophyllCol),
                                area(),
                                "chlorophyll",
                                { angle: 0 }
                            ]);
                            chloro.onUpdate(() => {
                                chloro.angle += dt() * 90;
                            });
                            break;
                        case "W":
                            // Water Ingredient
                            totalDots++;
                            add([
                                circle(8),
                                pos(centerX, centerY),
                                anchor("center"),
                                color(...C.waterCol),
                                area(),
                                z(10),
                                "water",
                                // Simple bobbing animation
                                { startY: centerY },
                            ]).onUpdate(function() {
                                this.pos.y = this.startY + Math.sin(time() * 4) * 2;
                            });
                            break;
                        case "S":
                            // Sun Ingredient
                            totalDots++;
                            add([
                                circle(8),
                                pos(centerX, centerY),
                                anchor("center"),
                                color(...C.sunCol),
                                area(),
                                z(10),
                                "sun",
                                { scaleVal: 0 },
                            ]).onUpdate(function() {
                                this.scale = vec2(1 + Math.sin(time() * 10) * 0.2);
                            });
                            break;
                        case "C":
                            // CO2 Ingredient
                            totalDots++;
                            add([
                                circle(8),
                                pos(centerX, centerY),
                                anchor("center"),
                                color(...C.co2Col),
                                area(),
                                z(10),
                                "co2",
                            ]);
                            break;
                        case "@":
                            playerSpawn = vec2(centerX, centerY);
                            // Spawn a dot under player too
                            totalDots++;
                            add([
                                circle(3),
                                pos(centerX, centerY),
                                anchor("center"),
                                color(...C.dotCol),
                                area(),
                                "dot",
                            ]);
                            break;
                        case "G":
                            ghostSpawns.push(vec2(centerX, centerY));
                            // Spawn a dot under ghost too
                            totalDots++;
                            add([
                                circle(3),
                                pos(centerX, centerY),
                                anchor("center"),
                                color(...C.dotCol),
                                area(),
                                "dot",
                            ]);
                            break;
                    }
                }
            }

            // -- UI: FORMULA BAR (Top) --
            // Background for the bar
            add([
                rect(width(), C.topBar),
                pos(0, 0),
                color(5, 20, 5),
                z(100),
            ]);
            add([
                text("PHOTOSYNTHESIS FORMULA:", { size: 14 }),
                pos(10, 12),
                color(200, 255, 200),
                z(101),
            ]);

            // Formula Indicators
            // Water Slot
            const uiWater = add([
                circle(10),
                pos(240, 20),
                color(50, 50, 50), // Dim when empty
                z(101),
                fixed(),
            ]);
            add([text("H2O", { size: 10 }), pos(240, 36), anchor("center"), z(101)]);

            // Sun Slot
            const uiSun = add([
                circle(10),
                pos(280, 20),
                color(50, 50, 50),
                z(101),
                fixed(),
            ]);
            add([text("Light", { size: 10 }), pos(280, 36), anchor("center"), z(101)]);

            // CO2 Slot
            const uiCO2 = add([
                circle(10),
                pos(320, 20),
                color(50, 50, 50),
                z(101),
                fixed(),
            ]);
            add([text("CO2", { size: 10 }), pos(320, 36), anchor("center"), z(101)]);

            // Function to update the bar appearance
            function updateFormulaUI() {
                uiWater.color = formula.water ? rgb(...C.waterCol) : rgb(50, 50, 50);
                uiSun.color = formula.sun ? rgb(...C.sunCol) : rgb(50, 50, 50);
                uiCO2.color = formula.co2 ? rgb(...C.co2Col) : rgb(50, 50, 50);
            }

            // Function to check if formula is complete
            function checkFormula() {
                updateFormulaUI();
                if (formula.water && formula.sun && formula.co2) {
                    // Trigger OXYGEN BLAST
                    powered = true;
                    powerTimer = C.powerUpTime;
                    
                    // Visual feedback
                    shake(5);
                    addKaboom(player.pos); // Explosion effect
                    
                    // Show "OXYGEN BLAST" text
                    const blastTxt = add([
                        text("OXYGEN BLAST!", { size: 24 }),
                        pos(center()),
                        anchor("center"),
                        color(0, 255, 255),
                        z(200),
                        lifespan(2),
                        move(vec2(0, -50), 20)
                    ]);

                    // Reset formula for next cycle
                    formula = { water: false, sun: false, co2: false };
                    wait(1, () => updateFormulaUI());
                }
            }

            // -- PLAYER SETUP --
            const player = add([
                circle(11), // Sunny is a seed
                pos(playerSpawn),
                anchor("center"),
                color(...C.playerCol),
                area({ shape: new Rect(vec2(-8, -8), 16, 16) }),
                z(50),
                { dir: vec2(0, 0), nextDir: vec2(0, 0) },
                "player",
            ]);
            // Add a little leaf sprite to Sunny
            player.add([
                rect(4, 8),
                pos(0, -11),
                anchor("bottom"),
                color(50, 200, 50),
                rotate(45),
            ]);

            // -- MOVEMENT LOGIC --
            function canMove(from, direction) {
                // Determine grid coordinates relative to the maze origin (0, offsetY)
                const target = from.add(direction.scale(T * 0.5));
                const localY = target.y - offsetY;
                
                const col = Math.floor(target.x / T);
                const row = Math.floor(localY / T);
                
                if (row < 0 || row >= mapH || col < 0 || col >= mapW) return false;
                return maze[row][col] !== "#";
            }

            // Input handling
            onKeyDown("left", () => player.nextDir = vec2(-1, 0));
            onKeyDown("right", () => player.nextDir = vec2(1, 0));
            onKeyDown("up", () => player.nextDir = vec2(0, -1));
            onKeyDown("down", () => player.nextDir = vec2(0, 1));
            onKeyDown("a", () => player.nextDir = vec2(-1, 0));
            onKeyDown("d", () => player.nextDir = vec2(1, 0));
            onKeyDown("w", () => player.nextDir = vec2(0, -1));
            onKeyDown("s", () => player.nextDir = vec2(0, 1));

            player.onUpdate(() => {
                if (gameOver) return;

                if (canMove(player.pos, player.nextDir)) {
                    player.dir = player.nextDir;
                }
                if (canMove(player.pos, player.dir)) {
                    player.move(player.dir.scale(C.playerSpeed));
                }
                
                // Keep player within bounds just in case
                player.pos.x = clamp(player.pos.x, T, (mapW - 1) * T);
                player.pos.y = clamp(player.pos.y, offsetY + T, offsetY + (mapH - 1) * T);
            });

            // -- COLLISIONS --
            
            function checkWin() {
                collected++;
                updateHUD();
                if (collected >= totalDots) {
                    gameOver = true;
                    wait(1, () => go("win", { score, lives }));
                }
            }

            // 1. Nutrients
            player.onCollide("dot", (d) => {
                destroy(d);
                score += 10;
                checkWin();
            });

            // 2. Chlorophyll (Bonus)
            player.onCollide("chlorophyll", (c) => {
                destroy(c);
                score += 50;
                // Add floating text
                add([
                    text("50", { size: 12 }),
                    pos(c.pos),
                    color(...C.chlorophyllCol),
                    z(100),
                    lifespan(1),
                    move(vec2(0, -20), 20)
                ]);
                checkWin();
            });

            // 3. Formula Items
            player.onCollide("water", (i) => {
                destroy(i);
                if (!formula.water) {
                    formula.water = true;
                    score += 100;
                    checkFormula();
                }
                checkWin();
            });
            player.onCollide("sun", (i) => {
                destroy(i);
                if (!formula.sun) {
                    formula.sun = true;
                    score += 100;
                    checkFormula();
                }
                checkWin();
            });
            player.onCollide("co2", (i) => {
                destroy(i);
                if (!formula.co2) {
                    formula.co2 = true;
                    score += 100;
                    checkFormula();
                }
                checkWin();
            });

            // -- POWER TIMER --
            onUpdate(() => {
                if (powered) {
                    powerTimer -= dt();
                    if (powerTimer <= 0) {
                        powered = false;
                        // Clear incomplete formula if any (optional, but cleaner)
                        formula = { water: false, sun: false, co2: false };
                        updateFormulaUI();
                    }
                }
            });

            // -- GHOST SPAWNING + AI --
            function spawnGhost(idx) {
                const sp = ghostSpawns.length > 0
                    ? ghostSpawns[idx % ghostSpawns.length]
                    : vec2(mapW * T / 2, offsetY + mapH * T / 2);
                
                const col = C.ghostCols[idx % C.ghostCols.length];
                
                // Visual variation: Cloud vs Aphid
                // Even indices = Pollution Cloud, Odd = Aphid
                const isAphid = (idx % 2 !== 0);

                const ghost = add([
                    circle(11),
                    pos(sp),
                    anchor("center"),
                    color(...col),
                    area({ shape: new Rect(vec2(-8, -8), 16, 16) }),
                    z(40),
                    {
                        baseCol: col,
                        dir: choose([vec2(1, 0), vec2(-1, 0), vec2(0, 1), vec2(0, -1)]),
                        turnTimer: 0,
                        spd: C.ghostSpeed + idx * 10,
                    },
                    "ghost",
                ]);

                // Add visual flair to ghosts
                if (isAphid) {
                    // Aphid legs/antennae
                    ghost.add([rect(2, 6), pos(-4, -12), color(...col), rotate(-20)]);
                    ghost.add([rect(2, 6), pos(4, -12), color(...col), rotate(20)]);
                } else {
                    // Pollution cloud lumpiness
                    ghost.add([circle(6), pos(-6, -4), color(...col)]);
                    ghost.add([circle(6), pos(6, 4), color(...col)]);
                }

                ghost.onUpdate(() => {
                    if (gameOver) return;

                    // Color logic: Glucose (White) when powered, else Base
                    if (powered) {
                        // Flash near end of power
                        if (powerTimer < 2) {
                            ghost.color = (Math.floor(time() * 10) % 2 === 0) 
                                ? rgb(...C.glucoseCol) 
                                : rgb(...ghost.baseCol);
                        } else {
                            ghost.color = rgb(...C.glucoseCol);
                        }
                    } else {
                        ghost.color = rgb(...ghost.baseCol);
                    }

                    ghost.turnTimer -= dt();
                    const toPlayer = player.pos.sub(ghost.pos);
                    // Flee if powered, chase if not
                    const chaseDir = powered ? toPlayer.unit().scale(-1) : toPlayer.unit();

                    if (ghost.turnTimer <= 0 || !canMove(ghost.pos, ghost.dir)) {
                        ghost.turnTimer = rand(0.5, 1.0);
                        const dirs = [vec2(1, 0), vec2(-1, 0), vec2(0, 1), vec2(0, -1)]
                            .filter(d => canMove(ghost.pos, d));

                        if (dirs.length > 0) {
                            if (rand() < 0.65) {
                                // Smart move
                                dirs.sort((a, b) => a.sub(chaseDir).len() - b.sub(chaseDir).len());
                                ghost.dir = dirs[0];
                            } else {
                                // Random move
                                ghost.dir = choose(dirs);
                            }
                        } else {
                            // Stuck? Reverse
                            ghost.dir = ghost.dir.scale(-1);
                        }
                    }

                    if (canMove(ghost.pos, ghost.dir)) {
                        const s = powered ? ghost.spd * 0.5 : ghost.spd;
                        ghost.move(ghost.dir.scale(s));
                    }
                    
                    // Clamping
                    ghost.pos.x = clamp(ghost.pos.x, T, (mapW - 1) * T);
                    ghost.pos.y = clamp(ghost.pos.y, offsetY + T, offsetY + (mapH - 1) * T);
                });
            }

            for (let i = 0; i < C.ghostCount; i++) {
                wait(i * 2, () => spawnGhost(i));
            }

            // -- COLLISIONS: PLAYER VS GHOST --
            player.onCollide("ghost", (g) => {
                if (gameOver) return;

                if (powered) {
                    // Eat Glucose
                    score += 200;
                    addKaboom(g.pos);
                    destroy(g);
                    updateHUD();
                    
                    // Floating text
                    add([
                        text("+200 Glucose", { size: 10 }),
                        pos(g.pos),
                        color(255, 255, 255),
                        lifespan(1),
                        z(200),
                        move(vec2(0, -30), 30)
                    ]);

                    // Respawn
                    const idx = Math.floor(rand(0, C.ghostCount));
                    wait(3, () => { if (!gameOver) spawnGhost(idx); });
                } else {
                    // Get hurt
                    lives--;
                    shake(10);
                    // Reset formula progress on death? No, keep it to be nice.
                    
                    if (lives <= 0) {
                        gameOver = true;
                        wait(0.5, () => go("gameover", score));
                    } else {
                        // Reset positions
                        player.pos = playerSpawn.clone();
                        player.dir = vec2(0, 0);
                        player.nextDir = vec2(0, 0);
                        
                        // Small invulnerability or pause?
                        // Just a flash
                        const flash = add([
                            rect(width(), height()),
                            color(255, 0, 0),
                            opacity(0.3),
                            fixed(),
                            z(900),
                            lifespan(0.1)
                        ]);
                        updateHUD();
                    }
                }
            });

            // -- HUD: BOTTOM STRIP --
            const hudY = mapH * T + offsetY + 10;
            
            const scoreLabel = add([
                text("Glucose: 0", { size: 16 }),
                pos(16, hudY),
                color(255, 220, 100),
                fixed(),
                z(100),
            ]);
            
            const livesLabel = add([
                text("Hydration: @ @ @", { size: 16 }),
                pos(width() - 16, hudY),
                anchor("topright"),
                color(100, 200, 255),
                fixed(),
                z(100),
            ]);
            
            const powerLabel = add([
                text("", { size: 16 }),
                pos(width() / 2, hudY),
                anchor("top"),
                color(0, 255, 255),
                fixed(),
                z(100),
            ]);

            function updateHUD() {
                scoreLabel.text = `Glucose: ${score}`;
                let l = "Hydration: ";
                for(let i=0; i<lives; i++) l += "â™¥ "; // Using heart char for hydration drops
                livesLabel.text = l;
            }

            onUpdate(() => {
                if (powered) {
                    powerLabel.text = `OXYGEN BLAST: ${Math.ceil(powerTimer)}s`;
                    powerLabel.color = rgb(wave(100, 255, time() * 10), 255, 255);
                } else {
                    powerLabel.text = "";
                }
            });
            
            updateHUD();

        });

        // ==================
        //  GAME OVER SCENE
        // ==================
        scene("gameover", (finalScore) => {
            add([
                rect(width(), height()),
                color(0, 0, 0),
            ]);
            add([
                text("WILTED...", { size: 48 }),
                pos(center()),
                anchor("center"),
                color(100, 100, 100)
            ]);
            add([
                text(`Glucose Produced: ${finalScore}`, { size: 24 }),
                pos(center().x, center().y + 60),
                anchor("center"),
                color(255, 220, 100)
            ]);
            add([
                text("Press SPACE to Photosynthesize Again", { size: 14 }),
                pos(center().x, center().y + 120),
                anchor("center"),
                color(140, 140, 170)
            ]);
            onKeyPress("space", () => go("game"));
            onClick(() => go("game"));
        });

        // ==================
        //  WIN SCENE
        // ==================
        scene("win", ({ score, lives }) => {
            add([
                rect(width(), height()),
                color(10, 50, 10),
            ]);
            add([
                text("FULLY GROWN!", { size: 40 }),
                pos(center()),
                anchor("center"),
                color(100, 255, 100)
            ]);
            add([
                text(`Total Glucose: ${score}\nHydration Left: ${lives}`, { size: 24, align: "center" }),
                pos(center().x, center().y + 70),
                anchor("center"),
                color(255, 255, 200)
            ]);
            add([
                text("The Cell is Healthy!", { size: 16 }),
                pos(center().x, center().y + 130),
                anchor("center"),
                color(100, 200, 255)
            ]);
            add([
                text("Press SPACE to Replay", { size: 14 }),
                pos(center().x, center().y + 160),
                anchor("center"),
                color(150, 150, 150)
            ]);
            onKeyPress("space", () => go("game"));
            onClick(() => go("game"));
        });

        // Start
        go("game");

    </script>
</body>

</html>