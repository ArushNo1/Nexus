<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photosynthesis Factory</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
</head>
<body style="margin: 0; padding: 0; background: #1a1a1a; font-family: Arial, sans-serif;">

<script>
/**
 * Photosynthesis Factory - Educational Drag & Drop Game
 * Learning Objectives â†’ Game Mechanics:
 * - Define photosynthesis â†’ Interactive tutorial with explicit feedback messages
 * - Identify inputs/outputs â†’ Drag 3 inputs (sun, water, COâ‚‚) to plant to create 2 outputs (Oâ‚‚, glucose)
 * - Explain importance â†’ Success messages connect oxygen to breathing, glucose to plant growth
 */

class AudioManager {
    constructor(scene) {
        this.scene = scene;
        this.enabled = true;
        this.audioContext = null;
        this.initAudio();
    }

    initAudio() {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.log('Web Audio API not supported');
            this.enabled = false;
        }
    }

    playSuccess() {
        if (!this.enabled || !this.audioContext) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.setValueAtTime(523, this.audioContext.currentTime); // C5
        oscillator.frequency.setValueAtTime(659, this.audioContext.currentTime + 0.1); // E5
        oscillator.frequency.setValueAtTime(784, this.audioContext.currentTime + 0.2); // G5
        
        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
        
        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + 0.5);
    }

    playDrop() {
        if (!this.enabled || !this.audioContext) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.2);
        
        gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
        
        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + 0.2);
    }

    playComplete() {
        if (!this.enabled || !this.audioContext) return;
        
        const frequencies = [261, 329, 392, 523]; // C major chord
        
        frequencies.forEach((freq, index) => {
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            
            oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime + index * 0.1);
            gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime + index * 0.1);
            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + index * 0.1 + 1);
            
            oscillator.start(this.audioContext.currentTime + index * 0.1);
            oscillator.stop(this.audioContext.currentTime + index * 0.1 + 1);
        });
    }
}

class MenuScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MenuScene' });
    }

    preload() {
        this.createAssets();
    }

    createAssets() {
        // Create background gradient texture
        const bgTexture = this.textures.createCanvas('bg-gradient', 800, 600);
        const bgCanvas = bgTexture.getCanvas();
        const bgCtx = bgCanvas.getContext('2d');
        
        const gradient = bgCtx.createLinearGradient(0, 0, 0, 600);
        gradient.addColorStop(0, '#87CEEB'); // Sky blue
        gradient.addColorStop(0.7, '#98FB98'); // Pale green
        gradient.addColorStop(1, '#228B22'); // Forest green
        
        bgCtx.fillStyle = gradient;
        bgCtx.fillRect(0, 0, 800, 600);
        
        bgTexture.refresh();

        // Create sun texture
        const sunTexture = this.textures.createCanvas('sun-texture', 100, 100);
        const sunCanvas = sunTexture.getCanvas();
        const sunCtx = sunCanvas.getContext('2d');
        
        // Sun body
        const sunGradient = sunCtx.createRadialGradient(50, 50, 10, 50, 50, 40);
        sunGradient.addColorStop(0, '#FFD700');
        sunGradient.addColorStop(1, '#FFA500');
        
        sunCtx.fillStyle = sunGradient;
        sunCtx.beginPath();
        sunCtx.arc(50, 50, 35, 0, Math.PI * 2);
        sunCtx.fill();
        
        // Sun rays
        sunCtx.strokeStyle = '#FFD700';
        sunCtx.lineWidth = 4;
        for (let i = 0; i < 12; i++) {
            const angle = (i * 30) * Math.PI / 180;
            sunCtx.beginPath();
            sunCtx.moveTo(50 + Math.cos(angle) * 40, 50 + Math.sin(angle) * 40);
            sunCtx.lineTo(50 + Math.cos(angle) * 48, 50 + Math.sin(angle) * 48);
            sunCtx.stroke();
        }
        
        sunTexture.refresh();

        // Create water droplet texture
        const waterTexture = this.textures.createCanvas('water-texture', 60, 80);
        const waterCanvas = waterTexture.getCanvas();
        const waterCtx = waterCanvas.getContext('2d');
        
        const waterGradient = waterCtx.createRadialGradient(30, 40, 5, 30, 40, 30);
        waterGradient.addColorStop(0, '#87CEEB');
        waterGradient.addColorStop(1, '#4169E1');
        
        waterCtx.fillStyle = waterGradient;
        waterCtx.beginPath();
        waterCtx.moveTo(30, 10);
        waterCtx.quadraticCurveTo(15, 25, 15, 45);
        waterCtx.quadraticCurveTo(15, 65, 30, 70);
        waterCtx.quadraticCurveTo(45, 65, 45, 45);
        waterCtx.quadraticCurveTo(45, 25, 30, 10);
        waterCtx.fill();
        
        // Water highlight
        waterCtx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        waterCtx.beginPath();
        waterCtx.ellipse(25, 30, 8, 15, 0, 0, Math.PI * 2);
        waterCtx.fill();
        
        waterTexture.refresh();

        // Create CO2 bubble texture
        const co2Texture = this.textures.createCanvas('co2-texture', 60, 60);
        const co2Canvas = co2Texture.getCanvas();
        const co2Ctx = co2Canvas.getContext('2d');
        
        const co2Gradient = co2Ctx.createRadialGradient(30, 30, 5, 30, 30, 25);
        co2Gradient.addColorStop(0, '#D3D3D3');
        co2Gradient.addColorStop(1, '#808080');
        
        co2Ctx.fillStyle = co2Gradient;
        co2Ctx.beginPath();
        co2Ctx.arc(30, 30, 25, 0, Math.PI * 2);
        co2Ctx.fill();
        
        // CO2 text
        co2Ctx.fillStyle = '#FFFFFF';
        co2Ctx.font = 'bold 14px Arial';
        co2Ctx.textAlign = 'center';
        co2Ctx.fillText('COâ‚‚', 30, 35);
        
        co2Texture.refresh();

        // Create plant texture
        const plantTexture = this.textures.createCanvas('plant-texture', 200, 200);
        const plantCanvas = plantTexture.getCanvas();
        const plantCtx = plantCanvas.getContext('2d');
        
        // Stem
        const stemGradient = plantCtx.createLinearGradient(95, 120, 105, 120);
        stemGradient.addColorStop(0, '#228B22');
        stemGradient.addColorStop(1, '#32CD32');
        
        plantCtx.fillStyle = stemGradient;
        plantCtx.fillRect(95, 120, 10, 60);
        
        // Leaves
        const leafGradient = plantCtx.createRadialGradient(100, 100, 10, 100, 100, 30);
        leafGradient.addColorStop(0, '#32CD32');
        leafGradient.addColorStop(1, '#228B22');
        
        plantCtx.fillStyle = leafGradient;
        
        // Left leaf
        plantCtx.beginPath();
        plantCtx.arc(80, 100, 25, 0, Math.PI * 2);
        plantCtx.fill();
        
        // Right leaf
        plantCtx.beginPath();
        plantCtx.arc(120, 100, 25, 0, Math.PI * 2);
        plantCtx.fill();
        
        // Center leaf (larger)
        plantCtx.beginPath();
        plantCtx.arc(100, 80, 30, 0, Math.PI * 2);
        plantCtx.fill();
        
        plantTexture.refresh();

        // Create oxygen texture
        const oxygenTexture = this.textures.createCanvas('oxygen-texture', 50, 50);
        const oxygenCanvas = oxygenTexture.getCanvas();
        const oxygenCtx = oxygenCanvas.getContext('2d');
        
        const oxygenGradient = oxygenCtx.createRadialGradient(25, 25, 5, 25, 25, 20);
        oxygenGradient.addColorStop(0, '#E0FFFF');
        oxygenGradient.addColorStop(1, '#87CEEB');
        
        oxygenCtx.fillStyle = oxygenGradient;
        oxygenCtx.beginPath();
        oxygenCtx.arc(25, 25, 20, 0, Math.PI * 2);
        oxygenCtx.fill();
        
        // O2 text
        oxygenCtx.fillStyle = '#000080';
        oxygenCtx.font = 'bold 12px Arial';
        oxygenCtx.textAlign = 'center';
        oxygenCtx.fillText('Oâ‚‚', 25, 30);
        
        oxygenTexture.refresh();

        // Create glucose texture (hexagon)
        const glucoseTexture = this.textures.createCanvas('glucose-texture', 60, 60);
        const glucoseCanvas = glucoseTexture.getCanvas();
        const glucoseCtx = glucoseCanvas.getContext('2d');
        
        const glucoseGradient = glucoseCtx.createRadialGradient(30, 30, 5, 30, 30, 25);
        glucoseGradient.addColorStop(0, '#F4A460');
        glucoseGradient.addColorStop(1, '#D2691E');
        
        glucoseCtx.fillStyle = glucoseGradient;
        glucoseCtx.beginPath();
        
        // Draw hexagon
        for (let i = 0; i < 6; i++) {
            const angle = (i * 60) * Math.PI / 180;
            const x = 30 + Math.cos(angle) * 20;
            const y = 30 + Math.sin(angle) * 20;
            if (i === 0) {
                glucoseCtx.moveTo(x, y);
            } else {
                glucoseCtx.lineTo(x, y);
            }
        }
        glucoseCtx.closePath();
        glucoseCtx.fill();
        
        // Glucose formula
        glucoseCtx.fillStyle = '#8B4513';
        glucoseCtx.font = 'bold 8px Arial';
        glucoseCtx.textAlign = 'center';
        glucoseCtx.fillText('Câ‚†Hâ‚â‚‚Oâ‚†', 30, 34);
        
        glucoseTexture.refresh();
    }

    create() {
        // Background
        this.add.image(400, 300, 'bg-gradient');
        
        // Decorative elements
        this.add.image(150, 100, 'sun-texture').setScale(0.8);
        this.add.image(650, 150, 'plant-texture').setScale(0.6);
        
        // Title with better styling
        const title = this.add.text(400, 120, 'PHOTOSYNTHESIS FACTORY', { 
            fontSize: '36px', 
            fill: '#2F4F2F', 
            fontWeight: 'bold',
            stroke: '#FFFFFF',
            strokeThickness: 2
        }).setOrigin(0.5);
        
        // Subtitle
        this.add.text(400, 180, 'Help plants make their own food!', { 
            fontSize: '20px', 
            fill: '#228B22', 
            fontWeight: 'bold',
            stroke: '#FFFFFF',
            strokeThickness: 1
        }).setOrigin(0.5);
        
        this.add.text(400, 220, 'Drag sunlight, water, and COâ‚‚ to the plant.', { 
            fontSize: '18px', 
            fill: '#2F4F2F',
            stroke: '#FFFFFF',
            strokeThickness: 1
        }).setOrigin(0.5);

        // Controls info with better formatting
        const controlsText = this.add.text(400, 290, 'CONTROLS', { 
            fontSize: '16px', 
            fill: '#2F4F2F', 
            fontWeight: 'bold' 
        }).setOrigin(0.5);
        
        this.add.text(400, 320, 'Mouse: Drag and drop inputs', { 
            fontSize: '14px', 
            fill: '#2F4F2F' 
        }).setOrigin(0.5);
        
        this.add.text(400, 340, 'Keyboard: Arrow keys + WASD + Space', { 
            fontSize: '14px', 
            fill: '#2F4F2F' 
        }).setOrigin(0.5);

        // Accessibility notice
        this.add.text(400, 380, 'Fully accessible with keyboard controls and high contrast mode', { 
            fontSize: '12px', 
            fill: '#4B0082', 
            fontStyle: 'italic' 
        }).setOrigin(0.5);

        // Enhanced start button
        const startBtn = this.add.graphics();
        startBtn.fillStyle(0x4CAF50);
        startBtn.fillRoundedRect(300, 420, 200, 60, 10);
        startBtn.lineStyle(3, 0x388E3C);
        startBtn.strokeRoundedRect(300, 420, 200, 60, 10);
        
        const startBtnZone = this.add.zone(400, 450, 200, 60)
            .setInteractive()
            .on('pointerover', () => {
                startBtn.clear();
                startBtn.fillStyle(0x66BB6A);
                startBtn.fillRoundedRect(300, 420, 200, 60, 10);
                startBtn.lineStyle(3, 0x388E3C);
                startBtn.strokeRoundedRect(300, 420, 200, 60, 10);
            })
            .on('pointerout', () => {
                startBtn.clear();
                startBtn.fillStyle(0x4CAF50);
                startBtn.fillRoundedRect(300, 420, 200, 60, 10);
                startBtn.lineStyle(3, 0x388E3C);
                startBtn.strokeRoundedRect(300, 420, 200, 60, 10);
            })
            .on('pointerdown', () => this.scene.start('GameScene'));

        this.add.text(400, 450, 'START FACTORY', { 
            fontSize: '20px', 
            fill: '#FFFFFF', 
            fontWeight: 'bold' 
        }).setOrigin(0.5);
    }
}

class GameScene extends Phaser.Scene {
    constructor() {
        super({ key: 'GameScene' });
    }

    create() {
        this.score = 0;
        this.timeLeft = 60;
        this.accessibilityMode = false;
        this.selectedItem = null;
        this.keyboardCursor = null;
        this.audioManager = new AudioManager(this);
        this.highContrast = false;

        this.setupUI();
        this.setupPlant();
        this.setupInputSystem();
        this.setupKeyboard();
        this.setupTimer();
        this.spawnInputs();
    }

    setupUI() {
        // Enhanced background with gradient
        const bgTexture = this.textures.createCanvas('game-bg', 800, 600);
        const bgCanvas = bgTexture.getCanvas();
        const bgCtx = bgCanvas.getContext('2d');
        
        const gradient = bgCtx.createLinearGradient(0, 0, 0, 600);
        gradient.addColorStop(0, '#87CEEB');
        gradient.addColorStop(0.6, '#98FB98');
        gradient.addColorStop(1, '#8FBC8F');
        
        bgCtx.fillStyle = gradient;
        bgCtx.fillRect(0, 0, 800, 600);
        
        bgTexture.refresh();
        this.add.image(400, 300, 'game-bg');
        
        // Ground with texture
        const groundTexture = this.textures.createCanvas('ground', 800, 100);
        const groundCanvas = groundTexture.getCanvas();
        const groundCtx = groundCanvas.getContext('2d');
        
        const groundGradient = groundCtx.createLinearGradient(0, 0, 0, 100);
        groundGradient.addColorStop(0, '#CD853F');
        groundGradient.addColorStop(1, '#8B4513');
        
        groundCtx.fillStyle = groundGradient;
        groundCtx.fillRect(0, 0, 800, 100);
        
        // Add some texture lines
        groundCtx.strokeStyle = 'rgba(139, 69, 19, 0.3)';
        groundCtx.lineWidth = 1;
        for (let i = 0; i < 10; i++) {
            groundCtx.beginPath();
            groundCtx.moveTo(0, i * 10);
            groundCtx.lineTo(800, i * 10 + 20);
            groundCtx.stroke();
        }
        
        groundTexture.refresh();
        this.add.image(400, 550, 'ground');
        
        // Enhanced UI elements
        this.scoreText = this.add.text(20, 20, 'Score: 0', { 
            fontSize: '22px', 
            fill: '#2F4F2F', 
            fontWeight: 'bold',
            stroke: '#FFFFFF',
            strokeThickness: 2
        });
        
        this.timerText = this.add.text(680, 20, 'Time: 60s', { 
            fontSize: '22px', 
            fill: '#2F4F2F', 
            fontWeight: 'bold',
            stroke: '#FFFFFF',
            strokeThickness: 2
        });

        // Instructions with better visibility
        const instructionBg = this.add.graphics();
        instructionBg.fillStyle(0x000000, 0.7);
        instructionBg.fillRoundedRect(50, 560, 700, 35, 5);
        
        this.add.text(400, 577, 'Drag sunlight â˜€, water ðŸ’§, and COâ‚‚ to the plant to make oxygen and glucose!', { 
            fontSize: '16px', 
            fill: '#FFFFFF', 
            fontWeight: 'bold' 
        }).setOrigin(0.5);

        // Accessibility toggle button
        const accessBtn = this.add.graphics();
        accessBtn.fillStyle(0x4CAF50);
        accessBtn.fillRoundedRect(20, 60, 120, 30, 5);
        
        const accessZone = this.add.zone(80, 75, 120, 30)
            .setInteractive()
            .on('pointerdown', () => this.toggleHighContrast());
        
        this.accessText = this.add.text(80, 75, 'High Contrast', { 
            fontSize: '12px', 
            fill: '#FFFFFF', 
            fontWeight: 'bold' 
        }).setOrigin(0.5);
    }

    toggleHighContrast() {
        this.highContrast = !this.highContrast;
        // This would typically update all visual elements for better contrast
        // For now, we'll just update the text
        this.accessText.setText(this.highContrast ? 'Normal Mode' : 'High Contrast');
    }

    setupPlant() {
        // Plant container with visual enhancement
        this.plantZone = this.add.zone(400, 400, 160, 160).setRectangleDropZone(160, 160);
        
        // Enhanced plant using created texture
        this.plantSprite = this.add.image(400, 400, 'plant-texture').setScale(0.8);
        
        // Animated drop zone indicator
        this.dropZoneGraphics = this.add.graphics();
        this.updateDropZoneVisual();
        
        // Animate the drop zone
        this.tweens.add({
            targets: this.dropZoneGraphics,
            alpha: 0.3,
            duration: 1000,
            yoyo: true,
            repeat: -1
        });

        // Plant inputs tracker with visual indicators
        this.plantInputs = { sun: false, water: false, co2: false };
        this.inputIndicators = {};
        
        // Create input indicator positions around the plant
        const indicatorPositions = {
            sun: { x: 350, y: 350 },
            water: { x: 450, y: 350 },
            co2: { x: 400, y: 320 }
        };
        
        Object.keys(indicatorPositions).forEach(input => {
            const pos = indicatorPositions[input];
            this.inputIndicators[input] = this.add.graphics();
            this.inputIndicators[input].lineStyle(2, 0xFF0000, 0.5);
            this.inputIndicators[input].strokeCircle(pos.x, pos.y, 15);
        });
    }

    updateDropZoneVisual() {
        this.dropZoneGraphics.clear();
        
        const allInputsCollected = this.plantInputs.sun && this.plantInputs.water && this.plantInputs.co2;
        const color = allInputsCollected ? 0x00FF00 : 0xFFD700;
        const alpha = allInputsCollected ? 0.8 : 0.5;
        
        this.dropZoneGraphics.lineStyle(4, color, alpha);
        this.dropZoneGraphics.strokeRoundedRect(320, 320, 160, 160, 10);
    }

    setupInputSystem() {
        this.inputs = [];
        this.outputs = [];
        this.inputTypes = [
            { key: 'sun', texture: 'sun-texture', shape: 'sun' },
            { key: 'water', texture: 'water-texture', shape: 'water' },
            { key: 'co2', texture: 'co2-texture', shape: 'co2' }
        ];
    }

    setupKeyboard() {
        this.cursors = this.input.keyboard.createCursorKeys();
        this.wasd = this.input.keyboard.addKeys('W,S,A,D,SPACE,TAB');
        
        // Enhanced keyboard cursor with better visibility
        this.keyboardCursor = this.add.graphics();
        this.keyboardCursor.lineStyle(4, 0xFFFF00);
        this.keyboardCursor.strokeCircle(0, 0, 25);
        this.keyboardCursor.lineStyle(2, 0x000000);
        this.keyboardCursor.strokeCircle(0, 0, 23);
        this.keyboardCursor.setPosition(100, 100).setVisible(false);
    }

    setupTimer() {
        this.time.addEvent({
            delay: 1000,
            callback: () => {
                this.timeLeft--;
                this.timerText.setText(`Time: ${this.timeLeft}s`);
                
                // Visual warning when time is running out
                if (this.timeLeft <= 10) {
                    this.timerText.setTint(0xFF0000);
                    if (this.timeLeft <= 5) {
                        this.cameras.main.shake(50, 0.01);
                    }
                }
                
                if (this.timeLeft <= 0) {
                    this.endGame();
                }
            },
            loop: true
        });
    }

    spawnInputs() {
        this.time.addEvent({
            delay: 2500,
            callback: this.spawnRandomInput,
            callbackScope: this,
            loop: true
        });

        // Spawn initial inputs with staggered timing
        this.inputTypes.forEach((type, index) => {
            this.time.delayedCall(index * 800, () => this.spawnRandomInput(), [], this);
        });
    }

    spawnRandomInput() {
        if (this.inputs.length >= 8) return;

        const inputType = Phaser.Utils.Array.GetRandom(this.inputTypes);
        const x = Phaser.Math.Between(80, 200);
        const y = Phaser.Math.Between(120, 250);

        const input = this.createInputSprite(x, y, inputType);
        this.inputs.push(input);

        // Enhanced removal with fade effect
        this.time.delayedCall(18000, () => {
            if (input && input.active) {
                this.tweens.add({
                    targets: input,
                    alpha: 0,
                    scale: 0.5,
                    duration: 1000,
                    onComplete: () => {
                        this.inputs = this.inputs.filter(i => i !== input);
                        if (input.active) input.destroy();
                    }
                });
            }
        });
    }

    createInputSprite(x, y, inputType) {
        const input = this.add.image(x, y, inputType.texture);
        input.setScale(0.6);
        input.inputType = inputType.key;
        input.setInteractive({ draggable: true });

        // Enhanced visual feedback
        input.on('pointerover', () => {
            input.setTint(0xCCCCCC);
            input.setScale(0.7);
        });

        input.on('pointerout', () => {
            input.clearTint();
            input.setScale(0.6);
        });

        input.on('dragstart', () => {
            input.setTint(0x888888);
            input.setScale(0.8);
            this.audioManager.playDrop();
        });

        input.on('drag', (pointer, dragX, dragY) => {
            input.x = dragX;
            input.y = dragY;
            
            // Visual feedback when near drop zone
            const distance = Phaser.Math.Distance.Between(dragX, dragY, 400, 400);
            if (distance < 100) {
                this.dropZoneGraphics.setTint(0x00FF00);
            } else {
                this.dropZoneGraphics.clearTint();
            }
        });

        input.on('dragend', () => {
            input.clearTint();
            input.setScale(0.6);
            this.dropZoneGraphics.clearTint();
            this.checkPlantDrop(input);
        });

        // Floating animation
        this.tweens.add({
            targets: input,
            y: y - 5,
            duration: 2000,
            yoyo: true,
            repeat: -1,
            ease: 'Sine.easeInOut'
        });

        return input;
    }

    checkPlantDrop(input) {
        const plantBounds = new Phaser.Geom.Rectangle(320, 320, 160, 160);
        const inputBounds = input.getBounds();

        if (Phaser.Geom.Rectangle.Overlaps(plantBounds, inputBounds)) {
            this.addInputToPlant(input);
        }
    }

    addInputToPlant(input) {
        const inputType = input.inputType;
        
        if (!this.plantInputs[inputType]) {
            this.plantInputs[inputType] = true;
            this.score += 10;
            this.updateScore();

            // Update visual indicator
            this.inputIndicators[inputType].clear();
            this.inputIndicators[inputType].lineStyle(3, 0x00FF00);
            this.inputIndicators[inputType].fillStyle(0x00FF00, 0.3);
            
            const pos = Object.keys(this.inputIndicators).indexOf(inputType);
            const positions = [
                { x: 350, y: 350 },
                { x: 450, y: 350 },
                { x: 400, y: 320 }
            ];
            
            this.inputIndicators[inputType].fillCircle(positions[pos].x, positions[pos].y, 15);

            // Remove input with effect
            this.tweens.add({
                targets: input,
                scale: 1.5,
                alpha: 0,
                duration: 500,
                onComplete: () => {
                    this.inputs = this.inputs.filter(i => i !== input);
                    input.destroy();
                }
            });

            this.audioManager.playSuccess();
            this.showInputFeedback(inputType);
            this.updateDropZoneVisual();

            // Check for complete photosynthesis
            if (this.plantInputs.sun && this.plantInputs.water && this.plantInputs.co2) {
                this.time.delayedCall(500, () => this.completePhotosynthesis(), [], this);
            }
        }
    }

    showInputFeedback(inputType) {
        const messages = {
            sun: 'Sunlight absorbed! â˜€ï¸\nPlants need light energy!',
            water: 'Water collected! ðŸ’§\nRoots drink from soil!',
            co2: 'COâ‚‚ captured! ðŸ«§\nTaken from the air!'
        };

        const colors = {
            sun: '#FFD700',
            water: '#4169E1',
            co2: '#808080'
        };

        const feedback = this.add.text(400, 280, messages[inputType], {
            fontSize: '16px', 
            fill: colors[inputType], 
            fontWeight: 'bold',
            align: 'center',
            stroke: '#FFFFFF',
            strokeThickness: 2
        }).setOrigin(0.5);

        this.tweens.add({
            targets: feedback,
            y: 230,
            alpha: 0,
            scale: 1.2,
            duration: 2000,
            ease: 'Power2',
            onComplete: () => feedback.destroy()
        });
    }

    completePhotosynthesis() {
        this.score += 50;
        this.updateScore();
        this.audioManager.playComplete();

        // Reset plant inputs with animation
        this.plantInputs = { sun: false, water: false, co2: false };
        
        Object.values(this.inputIndicators).forEach(indicator => {
            indicator.clear();
            indicator.lineStyle(2, 0xFF0000, 0.5);
        });
        
        const positions = [
            { x: 350, y: 350 },
            { x: 450, y: 350 },
            { x: 400, y: 320 }
        ];
        
        positions.forEach((pos, index) => {
            const keys = Object.keys(this.inputIndicators);
            this.inputIndicators[keys[index]].strokeCircle(pos.x, pos.y, 15);
        });

        // Enhanced plant animation
        this.tweens.add({
            targets: this.plantSprite,
            scale: 1.2,
            duration: 300,
            yoyo: true,
            onComplete: () => {
                this.createOutput(350, 320, 'oxygen');
                this.createOutput(450, 320, 'glucose');
            }
        });

        this.updateDropZoneVisual();

        // Enhanced success message
        const successBg = this.add.graphics();
        successBg.fillStyle(0x000000, 0.8);
        successBg.fillRoundedRect(200, 150, 400, 100, 10);
        
        const message = this.add.text(400, 200, 'PHOTOSYNTHESIS COMPLETE!', {
            fontSize: '20px', 
            fill: '#FFD700', 
            fontWeight: 'bold',
            align: 'center'
        }).setOrigin(0.5);

        const explanation = this.add.text(400, 225, 'Plants made oxygen (air we breathe)\nand glucose (food for growth)!', {
            fontSize: '14px', 
            fill: '#FFFFFF', 
            align: 'center'
        }).setOrigin(0.5);

        this.tweens.add({
            targets: [successBg, message, explanation],
            alpha: 0,
            duration: 4000,
            delay: 1000,
            onComplete: () => {
                successBg.destroy();
                message.destroy();
                explanation.destroy();
            }
        });
    }

    createOutput(x, y, type) {
        let output;
        
        if (type === 'oxygen') {
            output = this.add.image(x, y, 'oxygen-texture').setScale(0.8);
        } else if (type === 'glucose') {
            output = this.add.image(x, y, 'glucose-texture').setScale(0.8);
        }

        // Enhanced floating animation
        this.tweens.add({
            targets: output,
            y: y - 150,
            alpha: 0,
            scale: 1.5,
            duration: 3000,
            ease: 'Power2',
            onComplete: () => output.destroy()
        });

        // Particle effect
        this.createParticles(x, y, type === 'oxygen' ? 0x87CEEB : 0xDEB887);
    }

    createParticles(x, y, color) {
        for (let i = 0; i < 8; i++) {
            const particle = this.add.circle(x, y, 3, color);
            const angle = (i * 45) * Math.PI / 180;
            const distance = Phaser.Math.Between(30, 60);
            
            this.tweens.add({
                targets: particle,
                x: x + Math.cos(angle) * distance,
                y: y + Math.sin(angle) * distance - 20,
                alpha: 0,
                duration: 1500,
                delay: i * 50,
                onComplete: () => particle.destroy()
            });
        }
    }

    updateScore() {
        this.scoreText.setText(`Score: ${this.score}`);
        
        // Score animation
        this.tweens.add({
            targets: this.scoreText,
            scale: 1.2,
            duration: 200,
            yoyo: true
        });
    }

    update() {
        this.handleKeyboardInput();
    }

    handleKeyboardInput() {
        const speed = 4;
        
        if (this.cursors.up.isDown || this.wasd.W.isDown) {
            this.accessibilityMode = true;
            this.keyboardCursor.setVisible(true);
            this.keyboardCursor.y = Math.max(50, this.keyboardCursor.y - speed);
        }
        if (this.cursors.down.isDown || this.wasd.S.isDown) {
            this.accessibilityMode = true;
            this.keyboardCursor.setVisible(true);
            this.keyboardCursor.y = Math.min(550, this.keyboardCursor.y + speed);
        }
        if (this.cursors.left.isDown || this.wasd.A.isDown) {
            this.accessibilityMode = true;
            this.keyboardCursor.setVisible(true);
            this.keyboardCursor.x = Math.max(50, this.keyboardCursor.x - speed);
        }
        if (this.cursors.right.isDown || this.wasd.D.isDown) {
            this.accessibilityMode = true;
            this.keyboardCursor.setVisible(true);
            this.keyboardCursor.x = Math.min(750, this.keyboardCursor.x + speed);
        }

        if (Phaser.Input.Keyboard.JustDown(this.wasd.SPACE) && this.accessibilityMode) {
            this.handleKeyboardDrop();
        }
    }

    handleKeyboardDrop() {
        let nearestInput = null;
        let nearestDistance = Infinity;

        this.inputs.forEach(input => {
            const distance = Phaser.Math.Distance.Between(
                this.keyboardCursor.x, this.keyboardCursor.y,
                input.x, input.y
            );
            if (distance < nearestDistance && distance < 120) {
                nearestDistance = distance;
                nearestInput = input;
            }
        });

        if (nearestInput) {
            // Move input to plant
            this.tweens.add({
                targets: nearestInput,
                x: 400,
                y: 400,
                duration: 500,
                onComplete: () => this.checkPlantDrop(nearestInput)
            });
        }
    }

    endGame() {
        this.scene.start('ResultsScene', { score: this.score });
    }
}

class ResultsScene extends Phaser.Scene {
    constructor() {
        super({ key: 'ResultsScene' });
    }

    init(data) {
        this.finalScore = data.score;
    }

    preload() {
        // Reuse textures from menu scene if needed
        if (!this.textures.exists('bg-gradient')) {
            this.createResultsBG();
        }
    }

    createResultsBG() {
        const bgTexture = this.textures.createCanvas('results-bg', 800, 600);
        const bgCanvas = bgTexture.getCanvas();
        const bgCtx = bgCanvas.getContext('2d');
        
        const gradient = bgCtx.createRadialGradient(400, 300, 50, 400, 300, 400);
        gradient.addColorStop(0, '#32CD32');
        gradient.addColorStop(1, '#006400');
        
        bgCtx.fillStyle = gradient;
        bgCtx.fillRect(0, 0, 800, 600);
        
        bgTexture.refresh();
    }

    create() {
        // Background
        if (this.textures.exists('results-bg')) {
            this.add.image(400, 300, 'results-bg');
        } else {
            this.add.rectangle(400, 300, 800, 600, 0x228B22);
        }
        
        // Decorative elements
        if (this.textures.exists('plant-texture')) {
            this.add.image(200, 200, 'plant-texture').setScale(0.5);
            this.add.image(600, 200, 'plant-texture').setScale(0.5).setFlipX(true);
        }
        
        if (this.textures.exists('oxygen-texture')) {
            for (let i = 0; i < 5; i++) {
                const x = 100 + i * 150;
                const y = 100 + Math.sin(i) * 50;
                const oxygen = this.add.image(x, y, 'oxygen-texture').setScale(0.6);
                
                this.tweens.add({
                    targets: oxygen,
                    y: y - 20,
                    duration: 2000,
                    yoyo: true,
                    repeat: -1,
                    delay: i * 300
                });
            }
        }

        // Title with enhanced styling
        const title = this.add.text(400, 120, 'FACTORY COMPLETE!', { 
            fontSize: '42px', 
            fill: '#FFD700', 
            fontWeight: 'bold',
            stroke: '#228B22',
            strokeThickness: 4
        }).setOrigin(0.5);

        // Score display with better visual hierarchy
        this.add.text(400, 200, `Final Score: ${this.finalScore}`, { 
            fontSize: '28px', 
            fill: '#FFFFFF',
            stroke: '#228B22',
            strokeThickness: 2
        }).setOrigin(0.5);

        // Performance feedback
        let message = '';
        let messageColor = '#FFFFFF';
        
        if (this.finalScore >= 300) {
            message = 'PHOTOSYNTHESIS EXPERT!\nYou understand how plants make food perfectly!';
            messageColor = '#FFD700';
        } else if (this.finalScore >= 150) {
            message = 'GREAT WORK!\nYou helped plants make oxygen and glucose!';
            messageColor = '#90EE90';
        } else if (this.finalScore >= 50) {
            message = 'GOOD START!\nKeep learning about photosynthesis!';
            messageColor = '#87CEEB';
        } else {
            message = 'KEEP TRYING!\nRemember: Plants need sunlight, water, and COâ‚‚!';
            messageColor = '#FFA500';
        }

        this.add.text(400, 280, message, { 
            fontSize: '20px', 
            fill: messageColor, 
            align: 'center',
            fontWeight: 'bold',
            stroke: '#000000',
            strokeThickness: 1
        }).setOrigin(0.5);

        // Educational reminder
        const reminderBg = this.add.graphics();
        reminderBg.fillStyle(0x000000, 0.7);
        reminderBg.fillRoundedRect(100, 360, 600, 80, 10);
        
        this.add.text(400, 400, 'Remember: Photosynthesis is how plants make their own food\nusing sunlight, water, and COâ‚‚ to create oxygen and glucose!', { 
            fontSize: '16px', 
            fill: '#FFFFFF', 
            align: 'center',
            fontWeight: 'bold'
        }).setOrigin(0.5);

        // Enhanced play again button
        const playAgainBtn = this.add.graphics();
        playAgainBtn.fillStyle(0x4CAF50);
        playAgainBtn.fillRoundedRect(250, 480, 150, 50, 10);
        playAgainBtn.lineStyle(3, 0x388E3C);
        playAgainBtn.strokeRoundedRect(250, 480, 150, 50, 10);

        const playAgainZone = this.add.zone(325, 505, 150, 50)
            .setInteractive()
            .on('pointerover', () => {
                playAgainBtn.clear();
                playAgainBtn.fillStyle(0x66BB6A);
                playAgainBtn.fillRoundedRect(250, 480, 150, 50, 10);
                playAgainBtn.lineStyle(3, 0x388E3C);
                playAgainBtn.strokeRoundedRect(250, 480, 150, 50, 10);
            })
            .on('pointerout', () => {
                playAgainBtn.clear();
                playAgainBtn.fillStyle(0x4CAF50);
                playAgainBtn.fillRoundedRect(250, 480, 150, 50, 10);
                playAgainBtn.lineStyle(3, 0x388E3C);
                playAgainBtn.strokeRoundedRect(250, 480, 150, 50, 10);
            })
            .on('pointerdown', () => this.scene.start('GameScene'));

        this.add.text(325, 505, 'PLAY AGAIN', { 
            fontSize: '16px', 
            fill: '#FFFFFF', 
            fontWeight: 'bold' 
        }).setOrigin(0.5);

        // Menu button
        const menuBtn = this.add.graphics();
        menuBtn.fillStyle(0x2196F3);
        menuBtn.fillRoundedRect(400, 480, 150, 50, 10);
        menuBtn.lineStyle(3, 0x1976D2);
        menuBtn.strokeRoundedRect(400, 480, 150, 50, 10);

        const menuZone = this.add.zone(475, 505, 150, 50)
            .setInteractive()
            .on('pointerover', () => {
                menuBtn.clear();
                menuBtn.fillStyle(0x42A5F5);
                menuBtn.fillRoundedRect(400, 480, 150, 50, 10);
                menuBtn.lineStyle(3, 0x1976D2);
                menuBtn.strokeRoundedRect(400, 480, 150, 50, 10);
            })
            .on('pointerout', () => {
                menuBtn.clear();
                menuBtn.fillStyle(0x2196F3);
                menuBtn.fillRoundedRect(400, 480, 150, 50, 10);
                menuBtn.lineStyle(3, 0x1976D2);
                menuBtn.strokeRoundedRect(400, 480, 150, 50, 10);
            })
            .on('pointerdown', () => this.scene.start('MenuScene'));

        this.add.text(475, 505, 'MAIN MENU', { 
            fontSize: '16px', 
            fill: '#FFFFFF', 
            fontWeight: 'bold' 
        }).setOrigin(0.5);
    }
}

const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    backgroundColor: '#87CEEB',
    scene: [MenuScene, GameScene, ResultsScene],
    physics: {
        default: 'arcade',
        arcade: { debug: false }
    }
};

new Phaser.Game(config);
</script>

</body>
</html>