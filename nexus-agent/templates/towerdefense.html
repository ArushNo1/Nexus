<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Kaplay Tower Defense Template</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            background: #111;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="https://unpkg.com/kaplay@3001.0.19/dist/kaplay.js"></script>
    <script>
        // =============================================
        //  TOWER DEFENSE TEMPLATE — Kaplay.js
        //
        //  HOW IT WORKS:
        //    - Grid map: P = path, B = buildable, W = wall, S = start, E = end
        //    - Click green tiles to place towers (costs gold)
        //    - Enemies follow waypoints along the path
        //    - Towers auto-shoot the nearest enemy in range
        //    - Kill enemies to earn gold, survive all waves to win
        //
        //  SCENES: "game", "gameover", "win"
        //
        //  EDUCATIONAL POTENTIAL:
        //    - Enemies carry vocab/math labels — towers "solve" them
        //    - Require answering a question before placing a tower
        //    - Show lesson content between waves
        // =============================================

        // -- CONFIG: Tweak all gameplay values here --
        const C = {
            tile: 48,           // size of each grid square in pixels
            cols: 14,           // map width in tiles
            rows: 9,            // map height in tiles
            startGold: 80,      // gold player begins with
            startLives: 10,     // lives before game over
            towerCost: 30,      // gold cost to build one tower
            towerRange: 120,    // pixels — how far tower can shoot
            towerDmg: 12,       // damage per bullet
            towerFireRate: 1.0, // seconds between shots
            bulletSpeed: 350,   // bullet travel speed
            enemyHP: 40,        // hit points per enemy
            enemySpeed: 55,     // pixel/s movement speed
            totalWaves: 3,      // number of waves to survive
            enemiesPerWave: 6,  // enemies spawned each wave
            spawnInterval: 1.5, // seconds between spawns
            waveDelay: 4,       // pause between waves
            goldPerKill: 12,    // gold earned per kill
            bg: [15, 25, 20],
            pathCol: [60, 50, 40],
            buildCol: [25, 50, 30],
            wallCol: [15, 25, 20],
            towerCol: [80, 200, 255],
            enemyCol: [220, 60, 60],
            bulletCol: [255, 255, 180],
        };

        // -- MAP LAYOUT --
        const MAP = [
            "WWWWWWWWWWWWWW",
            "SPPPPPPWWWWWWW",
            "WBBBWBPWBBBWWW",
            "WBBBWBPWBBBWWW",
            "WBBBWBPPPPPPWW",
            "WWWWWWWBBBWPWW",
            "WWWWWWWBBBWPWW",
            "WWWWWWWWWWWPWW",
            "WWWWWWWWWWWEWW",
        ];

        // -- WAYPOINTS: ordered tile coords [col, row] enemies walk through --
        const WAYPOINTS = [
            [0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1], [6, 1],
            [6, 2], [6, 3], [6, 4],
            [7, 4], [8, 4], [9, 4], [10, 4], [11, 4],
            [11, 5], [11, 6], [11, 7], [11, 8],
        ];

        // Convert tile coords to pixel positions (center of each tile)
        const WP = WAYPOINTS.map(([c, r]) => vec2(c * C.tile + C.tile / 2, r * C.tile + C.tile / 2));

        kaplay({ width: C.cols * C.tile, height: C.rows * C.tile + 48, background: C.bg, crisp: true, letterbox: true });
        loadBean();

        // ==================
        //  GAME SCENE
        // ==================
        scene("game", () => {
            let gold = C.startGold;
            let lives = C.startLives;
            let wave = 0;
            let enemiesAlive = 0;
            let waveActive = false;

            // -- SECTION: Build the grid map from ASCII --
            for (let r = 0; r < MAP.length; r++) {
                for (let c = 0; c < MAP[r].length; c++) {
                    const ch = MAP[r][c];
                    const x = c * C.tile;
                    const y = r * C.tile;

                    if (ch === "P" || ch === "S" || ch === "E") {
                        // Path tiles — enemies walk on these
                        add([rect(C.tile, C.tile), pos(x, y), color(...C.pathCol), "path"]);
                    } else if (ch === "B") {
                        // Buildable tiles — player can click to place towers
                        add([rect(C.tile, C.tile), pos(x, y), color(...C.buildCol), area(), "build", { hasTower: false }]);
                    } else {
                        // Wall tiles — just decoration
                        add([rect(C.tile, C.tile), pos(x, y), color(...C.wallCol)]);
                    }
                }
            }

            // -- SECTION: Place towers by clicking green tiles --
            onClick("build", (tile) => {
                if (tile.hasTower || gold < C.towerCost) return;
                gold -= C.towerCost;
                tile.hasTower = true;
                tile.color = rgb(...C.wallCol); // hide the green

                const tx = tile.pos.x + C.tile / 2;
                const ty = tile.pos.y + C.tile / 2;

                // Tower sprite (simple colored rectangle)
                add([
                    rect(C.tile - 8, C.tile - 8), pos(tx, ty), anchor("center"),
                    color(...C.towerCol), outline(2, rgb(255, 255, 255)),
                    "tower", { fireCD: 0 },
                ]);

                // Faint range indicator circle
                add([circle(C.towerRange), pos(tx, ty), anchor("center"), color(255, 255, 255), opacity(0.05), z(-1)]);
            });

            // -- SECTION: Tower AI — find nearest enemy and shoot --
            onUpdate("tower", (t) => {
                t.fireCD -= dt();
                if (t.fireCD > 0) return;

                // Find closest enemy within range
                let nearest = null;
                let nearDist = Infinity;
                get("enemy").forEach((e) => {
                    const d = t.pos.dist(e.pos);
                    if (d < C.towerRange && d < nearDist) { nearDist = d; nearest = e; }
                });
                if (!nearest) return;

                // Fire a bullet toward that enemy
                t.fireCD = C.towerFireRate;
                const dir = nearest.pos.sub(t.pos).unit();
                add([
                    circle(4), pos(t.pos), color(...C.bulletCol),
                    move(dir, C.bulletSpeed),
                    area({ shape: new Rect(vec2(-4, -4), 8, 8) }),
                    offscreen({ destroy: true }), "tbullet",
                ]);
            });

            // -- SECTION: Bullet hits enemy --
            onCollide("tbullet", "enemy", (bullet, enemy) => {
                destroy(bullet);
                enemy.hp -= C.towerDmg;

                // Flash white on hit
                enemy.color = rgb(255, 255, 255);
                wait(0.08, () => { if (enemy.exists()) enemy.color = rgb(...C.enemyCol); });

                if (enemy.hp <= 0) {
                    gold += C.goldPerKill;
                    enemiesAlive--;
                    addKaboom(enemy.pos);
                    destroy(enemy);
                }
            });

            // -- SECTION: Spawn a single enemy at the start --
            function spawnEnemy() {
                add([
                    rect(C.tile - 14, C.tile - 14), pos(WP[0]), anchor("center"),
                    color(...C.enemyCol), area(), "enemy",
                    { hp: C.enemyHP, maxHP: C.enemyHP, speed: C.enemySpeed, waypointIdx: 0 },
                ]);
                enemiesAlive++;
            }

            // -- SECTION: Enemy movement — follow waypoints --
            onUpdate("enemy", (e) => {
                // Reached end of path — lose a life
                if (e.waypointIdx >= WP.length) {
                    lives--;
                    enemiesAlive--;
                    destroy(e);
                    shake(5);
                    if (lives <= 0) go("gameover", wave);
                    return;
                }
                // Move toward next waypoint
                const target = WP[e.waypointIdx];
                e.move(target.sub(e.pos).unit().scale(e.speed));
                if (e.pos.dist(target) < 4) { e.pos = target; e.waypointIdx++; }
            });

            // -- SECTION: Draw HP bars above enemies --
            onDraw(() => {
                get("enemy").forEach((e) => {
                    const barW = C.tile - 14;
                    const barH = 4;
                    const x = e.pos.x - barW / 2;
                    const y = e.pos.y - (C.tile - 14) / 2 - 8;
                    const ratio = Math.max(0, e.hp / e.maxHP);
                    drawRect({ pos: vec2(x, y), width: barW, height: barH, color: rgb(60, 20, 20) });
                    drawRect({ pos: vec2(x, y), width: barW * ratio, height: barH, color: ratio > 0.5 ? rgb(80, 220, 100) : rgb(220, 60, 60) });
                });
            });

            // -- SECTION: Wave management --
            function startNextWave() {
                wave++;
                if (wave > C.totalWaves) { go("win", { wave: wave - 1, gold }); return; }
                waveActive = true;
                let spawned = 0;

                const spawnLoop = loop(C.spawnInterval, () => {
                    if (spawned >= C.enemiesPerWave) { spawnLoop.cancel(); return; }
                    spawnEnemy();
                    spawned++;
                });
            }

            // When all enemies from current wave are dead, start the next wave
            onUpdate(() => {
                if (waveActive && enemiesAlive <= 0 && get("enemy").length === 0) {
                    waveActive = false;
                    wait(C.waveDelay, () => startNextWave());
                }
            });

            // -- SECTION: HUD --
            const hudY = C.rows * C.tile + 4;
            const goldHud = add([text("", { size: 14 }), pos(8, hudY + 4), color(255, 220, 80), fixed(), z(50)]);
            const livesHud = add([text("", { size: 14 }), pos(8, hudY + 24), color(255, 100, 100), fixed(), z(50)]);
            const waveHud = add([text("", { size: 14 }), pos(C.cols * C.tile / 2, hudY + 14), anchor("top"), color(200, 200, 220), fixed(), z(50)]);
            add([text("Click green to build", { size: 10 }), pos(C.cols * C.tile - 8, hudY + 28), anchor("topright"), color(100, 100, 120), fixed(), z(50)]);

            onUpdate(() => {
                goldHud.text = `Gold: ${gold}`;
                livesHud.text = `Lives: ${lives}`;
                waveHud.text = `Wave: ${wave}/${C.totalWaves}`;
            });

            // Kick off the first wave after a brief delay
            wait(2, () => startNextWave());
        });

        // ==================
        //  GAME OVER
        // ==================
        scene("gameover", (wave) => {
            add([text("GAME OVER", { size: 48 }), pos(center()), anchor("center"), color(220, 60, 60)]);
            add([text(`Survived ${wave - 1} waves`, { size: 22 }), pos(center().x, center().y + 50), anchor("center"), color(255, 220, 80)]);
            add([text("Press SPACE to retry", { size: 14 }), pos(center().x, center().y + 95), anchor("center"), color(150, 150, 180)]);
            onKeyPress("space", () => go("game"));
            onClick(() => go("game"));
        });

        // ==================
        //  WIN SCENE
        // ==================
        scene("win", ({ wave, gold }) => {
            add([text("ALL WAVES CLEARED!", { size: 40 }), pos(center()), anchor("center"), color(100, 255, 150)]);
            add([text(`Gold remaining: ${gold}`, { size: 22 }), pos(center().x, center().y + 50), anchor("center"), color(255, 220, 80)]);
            add([text("Press SPACE to play again", { size: 14 }), pos(center().x, center().y + 95), anchor("center"), color(150, 150, 180)]);
            onKeyPress("space", () => go("game"));
            onClick(() => go("game"));
        });

        go("game");
    </script>
</body>

</html>
