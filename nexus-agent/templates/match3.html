<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Kaplay Match-3 Template</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            background: #111;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="https://unpkg.com/kaplay@3001.0.19/dist/kaplay.js"></script>
    <script>
        // =============================================
        //  MATCH-3 TEMPLATE — Kaplay.js
        //
        //  HOW IT WORKS:
        //    - Grid of colored gems. Click two adjacent gems to swap them.
        //    - If the swap creates a line of 3+ same-color gems, they are removed.
        //    - Gems above fall down (gravity), empty top rows get new random gems.
        //    - Score points for each gem removed. Reach the target score to win.
        //
        //  SCENES: "game", "gameover", "win"
        //
        //  EDUCATIONAL POTENTIAL:
        //    - Gems display letters/numbers — match groups that form words or equations
        //    - Only allow swaps that answer a question correctly
        //    - Gems represent elements, compounds, historical dates, etc.
        // =============================================

        // -- CONFIG --
        const C = {
            cols: 7,             // board width
            rows: 7,             // board height
            tile: 56,            // gem size in pixels
            pad: 4,              // padding between gems
            numTypes: 5,         // number of gem colors (keep low for more matches)
            scorePerGem: 10,     // points per gem cleared
            targetScore: 500,    // score needed to win
            timeLimit: 90,       // seconds
            bg: [20, 15, 30],
            colors: [            // gem colors — one per type
                [220, 50, 50],   // red
                [50, 180, 50],   // green
                [50, 100, 220],  // blue
                [220, 200, 40],  // yellow
                [180, 50, 200],  // purple
            ],
        };

        const W = C.cols * C.tile;
        const H = C.rows * C.tile;

        kaplay({ width: W, height: H + 48, background: C.bg, crisp: true, letterbox: true });
        loadBean();

        // ==================
        //  GAME SCENE
        // ==================
        scene("game", () => {
            let score = 0;
            let timer = C.timeLimit;
            let selected = null;  // first gem the player clicked
            let busy = false;     // true while processing matches/gravity

            // -- SECTION: Board state --
            // board[row][col] = gem type (0 to numTypes-1)
            // gems[row][col]  = the Kaplay game object for that cell
            const board = [];
            const gems = [];

            // Pixel position for a gem at (row, col)
            function gemPos(row, col) {
                return vec2(col * C.tile + C.tile / 2, row * C.tile + C.tile / 2);
            }

            // Random gem type
            function randType() {
                return Math.floor(Math.random() * C.numTypes);
            }

            // -- SECTION: Create a gem game object at (row, col) --
            function createGem(row, col, type) {
                const p = gemPos(row, col);
                const g = add([
                    rect(C.tile - C.pad * 2, C.tile - C.pad * 2, { radius: 6 }),
                    pos(p), anchor("center"),
                    color(...C.colors[type]),
                    area(), "gem",
                    { gRow: row, gCol: col, gType: type },
                ]);
                return g;
            }

            // -- SECTION: Initialize board with no initial matches --
            function initBoard() {
                for (let r = 0; r < C.rows; r++) {
                    board[r] = [];
                    gems[r] = [];
                    for (let c = 0; c < C.cols; c++) {
                        let t;
                        // Avoid placing 3-in-a-row during setup
                        do { t = randType(); } while (
                            (c >= 2 && board[r][c - 1] === t && board[r][c - 2] === t) ||
                            (r >= 2 && board[r - 1][c] === t && board[r - 2][c] === t)
                        );
                        board[r][c] = t;
                        gems[r][c] = createGem(r, c, t);
                    }
                }
            }

            // -- SECTION: Find all matches (3+ in a row/column) --
            function findMatches() {
                const matched = new Set();

                // Horizontal
                for (let r = 0; r < C.rows; r++) {
                    for (let c = 0; c < C.cols - 2; c++) {
                        const t = board[r][c];
                        if (t < 0) continue;
                        if (board[r][c + 1] === t && board[r][c + 2] === t) {
                            matched.add(`${r},${c}`);
                            matched.add(`${r},${c + 1}`);
                            matched.add(`${r},${c + 2}`);
                        }
                    }
                }
                // Vertical
                for (let c = 0; c < C.cols; c++) {
                    for (let r = 0; r < C.rows - 2; r++) {
                        const t = board[r][c];
                        if (t < 0) continue;
                        if (board[r + 1][c] === t && board[r + 2][c] === t) {
                            matched.add(`${r},${c}`);
                            matched.add(`${r + 1},${c}`);
                            matched.add(`${r + 2},${c}`);
                        }
                    }
                }
                return matched;
            }

            // -- SECTION: Remove matched gems, apply gravity, fill empty --
            function resolveBoard() {
                const matched = findMatches();
                if (matched.size === 0) { busy = false; return; }

                // Destroy matched gems
                matched.forEach((key) => {
                    const [r, c] = key.split(",").map(Number);
                    if (gems[r][c]) { destroy(gems[r][c]); gems[r][c] = null; }
                    board[r][c] = -1;
                    score += C.scorePerGem;
                });

                // Check win
                if (score >= C.targetScore) { go("win", score); return; }

                // Gravity: shift gems down to fill gaps
                wait(0.2, () => {
                    for (let c = 0; c < C.cols; c++) {
                        let writeRow = C.rows - 1;
                        for (let r = C.rows - 1; r >= 0; r--) {
                            if (board[r][c] >= 0) {
                                board[writeRow][c] = board[r][c];
                                if (writeRow !== r) board[r][c] = -1;
                                writeRow--;
                            }
                        }
                        // Fill empty rows at top with new gems
                        for (let r = writeRow; r >= 0; r--) {
                            board[r][c] = randType();
                        }
                    }

                    // Rebuild all gem objects from board state
                    for (let r = 0; r < C.rows; r++) {
                        for (let c = 0; c < C.cols; c++) {
                            if (gems[r][c]) destroy(gems[r][c]);
                            gems[r][c] = createGem(r, c, board[r][c]);
                        }
                    }

                    // Check for chain reactions (new matches from gravity)
                    wait(0.15, () => resolveBoard());
                });
            }

            // -- SECTION: Swap two gems --
            function swapGems(r1, c1, r2, c2) {
                // Swap board state
                const tmp = board[r1][c1];
                board[r1][c1] = board[r2][c2];
                board[r2][c2] = tmp;

                // Swap game objects
                if (gems[r1][c1]) { destroy(gems[r1][c1]); }
                if (gems[r2][c2]) { destroy(gems[r2][c2]); }
                gems[r1][c1] = createGem(r1, c1, board[r1][c1]);
                gems[r2][c2] = createGem(r2, c2, board[r2][c2]);
            }

            // -- SECTION: Click handler — select and swap gems --
            onClick("gem", (g) => {
                if (busy) return;

                if (!selected) {
                    // First click — highlight this gem
                    selected = g;
                    g.outline = { width: 3, color: rgb(255, 255, 255) };
                    return;
                }

                // Second click — check adjacency
                const dr = Math.abs(g.gRow - selected.gRow);
                const dc = Math.abs(g.gCol - selected.gCol);
                const isAdjacent = (dr + dc) === 1;

                if (!isAdjacent || g === selected) {
                    // Not adjacent — deselect and pick new
                    if (selected.exists()) selected.outline = null;
                    selected = g;
                    g.outline = { width: 3, color: rgb(255, 255, 255) };
                    return;
                }

                // Swap the two gems
                busy = true;
                if (selected.exists()) selected.outline = null;
                const r1 = selected.gRow, c1 = selected.gCol;
                const r2 = g.gRow, c2 = g.gCol;

                swapGems(r1, c1, r2, c2);

                // Check if swap created a match
                const matched = findMatches();
                if (matched.size === 0) {
                    // No match — swap back
                    wait(0.15, () => {
                        swapGems(r1, c1, r2, c2);
                        busy = false;
                    });
                } else {
                    // Valid match — resolve
                    wait(0.15, () => resolveBoard());
                }

                selected = null;
            });

            // -- SECTION: Initialize --
            initBoard();

            // -- SECTION: Timer countdown --
            onUpdate(() => {
                timer -= dt();
                if (timer <= 0) go("gameover", score);
            });

            // -- SECTION: HUD --
            const hudY = C.rows * C.tile + 4;
            const scoreHud = add([text("", { size: 16 }), pos(8, hudY + 12), color(255, 220, 80), fixed(), z(50)]);
            const timerHud = add([text("", { size: 16 }), pos(W - 8, hudY + 12), anchor("topright"), color(200, 200, 220), fixed(), z(50)]);
            const goalHud = add([text(`Goal: ${C.targetScore}`, { size: 12 }), pos(W / 2, hudY + 12), anchor("top"), color(120, 120, 150), fixed(), z(50)]);

            onUpdate(() => {
                scoreHud.text = `Score: ${score}`;
                timerHud.text = `Time: ${Math.ceil(timer)}`;
            });
        });

        // ==================
        //  GAME OVER
        // ==================
        scene("gameover", (score) => {
            add([text("TIME'S UP", { size: 48 }), pos(center()), anchor("center"), color(220, 60, 60)]);
            add([text(`Score: ${score}`, { size: 24 }), pos(center().x, center().y + 50), anchor("center"), color(255, 220, 80)]);
            add([text("Press SPACE to retry", { size: 14 }), pos(center().x, center().y + 90), anchor("center"), color(150, 150, 180)]);
            onKeyPress("space", () => go("game"));
            onClick(() => go("game"));
        });

        // ==================
        //  WIN SCENE
        // ==================
        scene("win", (score) => {
            add([text("YOU WIN!", { size: 48 }), pos(center()), anchor("center"), color(100, 255, 150)]);
            add([text(`Score: ${score}`, { size: 24 }), pos(center().x, center().y + 50), anchor("center"), color(255, 220, 80)]);
            add([text("Press SPACE to play again", { size: 14 }), pos(center().x, center().y + 90), anchor("center"), color(150, 150, 180)]);
            onKeyPress("space", () => go("game"));
            onClick(() => go("game"));
        });

        go("game");
    </script>
</body>

</html>
