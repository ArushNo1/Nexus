<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Kaplay Quiz Runner Template</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            background: #111;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="https://unpkg.com/kaplay@3001.0.19/dist/kaplay.js"></script>
    <script>
        // =============================================
        //  QUIZ RUNNER TEMPLATE — Kaplay.js
        //  Arrow keys / WASD to move left/right, Space to jump
        //
        //  ARCHITECTURE:
        //    Three scenes: "game" (main runner), "gameover" (fell or too many wrong), "win" (all questions answered).
        //    Auto-scrolling endless runner with quiz gates — player must choose the correct answer lane.
        //    The screen scrolls left automatically. Player moves between 3 lanes (top, middle, bottom).
        //    Quiz gates appear: 3 answer blocks spanning the 3 lanes. Only the correct answer lane is safe.
        //    Hitting wrong answer = lose HP. Hitting correct answer = score + proceed.
        //    After all questions are answered, player wins. HP dropping to 0 = game over.
        //
        //  THIS IS THE MOST DIRECTLY EDUCATIONAL TEMPLATE:
        //    - Questions and answers are defined in a simple QUESTIONS[] array
        //    - The AI should populate QUESTIONS[] with lesson-specific content
        //    - Each question has 1 correct and 2 wrong answers mapped to lanes
        //    - Question text appears as a banner before the answer gate reaches the player
        //    - Supports any subject: math, vocabulary, science, history, etc.
        //    - Score tracks both correct answers and speed bonus
        //    - Visual/audio feedback for correct vs wrong answers
        // =============================================

        // -- CONFIG: All tunable gameplay constants --
        const C = {
            scrollSpeed: 120,      // pixels/sec the world scrolls left (difficulty)
            playerSpeed: 250,      // vertical lane-switch speed
            playerHP: 3,           // wrong answers allowed before game over
            gateSpacing: 500,      // pixels between quiz gates
            laneCount: 3,          // number of answer lanes (top, mid, bot)
            laneHeight: 60,        // vertical space per lane
            floorY: 320,          // ground level
            bg: [12, 15, 30],
            playerCol: [80, 220, 255],
            correctCol: [80, 220, 120],    // correct answer block color
            wrongCol: [220, 80, 80],        // wrong answer block color (revealed after hit)
            neutralCol: [60, 70, 100],      // answer block color before reveal
            questionCol: [255, 220, 80],    // question text color
        };

        // -- QUESTIONS: Array of {question, answers, correct} --
        // answers[0..2] map to lanes [top, mid, bot]. correct = index of right answer (0, 1, or 2).
        // The AI should populate this array with lesson content.
        // The template shuffles answer positions so the correct answer isn't always the same lane.
        const QUESTIONS = [
            {
                question: "What is 7 × 8?",
                answers: ["56", "54", "63"],
                correct: 0,  // "56" is correct
            },
            {
                question: "What planet is closest to the Sun?",
                answers: ["Venus", "Mercury", "Mars"],
                correct: 1,  // "Mercury" is correct
            },
            {
                question: "What is H₂O commonly known as?",
                answers: ["Salt", "Sugar", "Water"],
                correct: 2,  // "Water" is correct
            },
            {
                question: "What is the past tense of 'run'?",
                answers: ["Ran", "Runned", "Running"],
                correct: 0,  // "Ran" is correct
            },
            {
                question: "How many sides does a hexagon have?",
                answers: ["5", "7", "6"],
                correct: 2,  // "6" is correct
            },
            {
                question: "What gas do plants absorb?",
                answers: ["Oxygen", "Nitrogen", "Carbon Dioxide"],
                correct: 2,  // "Carbon Dioxide" is correct
            },
        ];

        // -- Shuffle answer positions for each question so correct lane varies --
        // Modifies QUESTIONS in-place: randomizes answer order and updates correct index.
        function shuffleAnswers() {
            QUESTIONS.forEach((q) => {
                const correctAnswer = q.answers[q.correct];
                // Fisher-Yates shuffle on answers array
                for (let i = q.answers.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [q.answers[i], q.answers[j]] = [q.answers[j], q.answers[i]];
                }
                q.correct = q.answers.indexOf(correctAnswer);
            });
        }

        const canvasW = 800;
        const canvasH = 420;
        kaplay({ width: canvasW, height: canvasH, background: C.bg, crisp: true, letterbox: true });
        loadBean();

        // ==================
        //  GAME SCENE
        // ==================
        scene("game", () => {
            shuffleAnswers(); // re-shuffle each game start

            let score = 0;
            let hp = C.playerHP;
            let questionIdx = 0;
            let nextGateX = canvasW + 200; // where the next gate spawns (world X)
            let answered = new Set();      // track which gates have been resolved

            // Lane Y positions (centered around floorY - laneHeight)
            const laneYs = [];
            for (let i = 0; i < C.laneCount; i++) {
                laneYs.push(C.floorY - (C.laneCount - 1 - i) * C.laneHeight);
            }
            const playerLaneStart = 1; // start in middle lane

            // -- GROUND --
            add([
                rect(canvasW, canvasH - C.floorY + C.laneHeight),
                pos(0, C.floorY + C.laneHeight / 2),
                color(30, 35, 50),
                fixed(),
                z(0),
            ]);

            // -- Lane lines (visual guides) --
            for (let i = 0; i < C.laneCount; i++) {
                add([
                    rect(canvasW, 1),
                    pos(0, laneYs[i] + C.laneHeight / 2),
                    color(255, 255, 255),
                    opacity(0.06),
                    fixed(),
                    z(1),
                ]);
            }

            // -- PLAYER --
            let currentLane = playerLaneStart;
            const player = add([
                rect(28, 28, { radius: 6 }),
                pos(100, laneYs[currentLane]),
                anchor("center"),
                color(...C.playerCol),
                area(),
                z(20),
                "player",
            ]);

            // Smooth lane switching
            let targetY = laneYs[currentLane];

            // -- CONTROLS: Switch lanes --
            onKeyPress("up", () => { if (currentLane > 0) currentLane--; targetY = laneYs[currentLane]; });
            onKeyPress("w", () => { if (currentLane > 0) currentLane--; targetY = laneYs[currentLane]; });
            onKeyPress("down", () => { if (currentLane < C.laneCount - 1) currentLane++; targetY = laneYs[currentLane]; });
            onKeyPress("s", () => { if (currentLane < C.laneCount - 1) currentLane++; targetY = laneYs[currentLane]; });

            // -- Smooth player vertical movement --
            onUpdate(() => {
                player.pos.y = lerp(player.pos.y, targetY, dt() * 12);
            });

            // -- SCROLLING BACKGROUND STARS --
            for (let i = 0; i < 30; i++) {
                add([
                    circle(rand(1, 3)),
                    pos(rand(0, canvasW), rand(0, C.floorY)),
                    color(255, 255, 255),
                    opacity(rand(0.1, 0.3)),
                    z(-1),
                    "bgstar",
                ]);
            }
            onUpdate("bgstar", (s) => {
                s.pos.x -= C.scrollSpeed * 0.3 * dt();
                if (s.pos.x < -10) s.pos.x = canvasW + 10;
            });

            // -- SPAWN QUIZ GATES --
            // A gate = 3 answer blocks (one per lane) at the same X position.
            // One block is the correct answer. Colliding reveals the result.
            function spawnGate(qIdx) {
                if (qIdx >= QUESTIONS.length) return;
                const q = QUESTIONS[qIdx];
                const gateX = nextGateX;

                // Show question banner ahead of the gate
                const qText = add([
                    text(q.question, { size: 14, width: 280 }),
                    pos(gateX - 80, laneYs[0] - 50),
                    color(...C.questionCol),
                    z(25),
                    "scrollable",
                    { gateIdx: qIdx, isQuestion: true },
                ]);

                // Create answer blocks for each lane
                for (let lane = 0; lane < C.laneCount; lane++) {
                    const isCorrect = lane === q.correct;
                    const block = add([
                        rect(80, C.laneHeight - 8, { radius: 6 }),
                        pos(gateX, laneYs[lane]),
                        anchor("center"),
                        color(...C.neutralCol),
                        outline(2, rgb(80, 90, 120)),
                        area(),
                        z(15),
                        "answerblock",
                        "scrollable",
                        {
                            gateIdx: qIdx,
                            lane,
                            isCorrect,
                            revealed: false,
                        },
                    ]);

                    // Answer label on the block
                    block.add([
                        text(q.answers[lane], { size: 11, width: 70 }),
                        anchor("center"),
                        color(220, 220, 240),
                    ]);
                }

                nextGateX += C.gateSpacing;
            }

            // -- SCROLL all "scrollable" entities left --
            onUpdate("scrollable", (s) => {
                s.pos.x -= C.scrollSpeed * dt();
                // Cleanup when off-screen left
                if (s.pos.x < -200) destroy(s);
            });

            // -- PLAYER COLLISION WITH ANSWER BLOCKS --
            onCollide("player", "answerblock", (p, block) => {
                if (block.revealed) return;
                if (answered.has(block.gateIdx)) return;
                answered.add(block.gateIdx);

                // Reveal all blocks in this gate
                get("answerblock").forEach((b) => {
                    if (b.gateIdx === block.gateIdx) {
                        b.revealed = true;
                        b.color = b.isCorrect ? rgb(...C.correctCol) : rgb(...C.wrongCol);
                    }
                });

                if (block.isCorrect) {
                    // Correct answer!
                    score += 100;
                    addKaboom(player.pos);
                    // Green flash
                    flash(rgb(80, 220, 120));

                    // Show "CORRECT!" label
                    add([
                        text("CORRECT!", { size: 24 }),
                        pos(player.pos.x + 60, player.pos.y),
                        anchor("center"),
                        color(80, 255, 120),
                        z(100),
                        lifespan(1.0),
                        "scrollable",
                    ]);
                } else {
                    // Wrong answer
                    hp--;
                    shake(8);
                    flash(rgb(220, 60, 60));

                    add([
                        text("WRONG!", { size: 24 }),
                        pos(player.pos.x + 60, player.pos.y),
                        anchor("center"),
                        color(255, 80, 80),
                        z(100),
                        lifespan(1.0),
                        "scrollable",
                    ]);

                    if (hp <= 0) {
                        go("gameover", { score, answered: answered.size, total: QUESTIONS.length });
                    }
                }

                // Check win condition
                if (answered.size >= QUESTIONS.length) {
                    wait(1.5, () => {
                        go("win", { score, hp, total: QUESTIONS.length });
                    });
                }
            });

            // -- SPAWN GATES: Pre-spawn first few, then spawn more as player progresses --
            // Spawn all gates upfront based on question count
            for (let i = 0; i < QUESTIONS.length; i++) {
                spawnGate(i);
            }

            // -- DECORATIVE GROUND MARKERS (dashes on ground showing movement) --
            loop(0.5, () => {
                add([
                    rect(20 + rand(0, 30), 2),
                    pos(canvasW + 10, C.floorY + C.laneHeight / 2 + rand(5, 40)),
                    color(255, 255, 255),
                    opacity(0.08),
                    z(0),
                    "scrollable",
                ]);
            });

            // -- HUD --
            const scoreText = add([
                text(`Score: ${score}`, { size: 16 }),
                pos(8, 8), color(255, 220, 80), fixed(), z(50),
            ]);
            const hpText = add([
                text("", { size: 16 }),
                pos(8, 28), color(80, 220, 100), fixed(), z(50),
            ]);
            const progressText = add([
                text("", { size: 14 }),
                pos(canvasW - 8, 8), anchor("topright"), color(200, 200, 220), fixed(), z(50),
            ]);
            add([
                text("UP/DOWN or W/S to switch lanes", { size: 10 }),
                pos(canvasW / 2, canvasH - 12), anchor("center"), color(80, 80, 110), fixed(), z(50),
            ]);

            onUpdate(() => {
                scoreText.text = `Score: ${score}`;
                hpText.text = `Lives: ${"♥ ".repeat(hp)}`;
                progressText.text = `Q: ${answered.size}/${QUESTIONS.length}`;
            });
        });

        // ==================
        //  GAME OVER SCENE
        // ==================
        scene("gameover", ({ score, answered, total }) => {
            add([text("GAME OVER", { size: 48 }), pos(center()), anchor("center"), color(220, 60, 60)]);
            add([text(`Score: ${score}  |  Answered: ${answered}/${total}`, { size: 20 }), pos(center().x, center().y + 55), anchor("center"), color(255, 220, 80)]);
            add([text("Press SPACE to retry", { size: 16 }), pos(center().x, center().y + 100), anchor("center"), color(150, 150, 180)]);
            onKeyPress("space", () => go("game"));
            onClick(() => go("game"));
        });

        // ==================
        //  WIN SCENE
        // ==================
        scene("win", ({ score, hp, total }) => {
            add([text("ALL CORRECT!", { size: 44 }), pos(center()), anchor("center"), color(100, 255, 150)]);
            add([text(`Score: ${score}  |  Lives left: ${hp}`, { size: 20 }), pos(center().x, center().y + 50), anchor("center"), color(255, 220, 80)]);
            add([text(`${total} questions answered!`, { size: 16 }), pos(center().x, center().y + 85), anchor("center"), color(200, 200, 220)]);
            add([text("Press SPACE to play again", { size: 14 }), pos(center().x, center().y + 120), anchor("center"), color(150, 150, 180)]);
            onKeyPress("space", () => go("game"));
            onClick(() => go("game"));
        });

        // -- ENTRY POINT --
        go("game");
    </script>
</body>

</html>
