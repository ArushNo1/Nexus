<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Kaplay Shoot 'em Up Template</title>
    <style>* { margin: 0; padding: 0; } body { background: #000; overflow: hidden; } canvas { display: block; }</style>
</head>
<body>
<script src="https://unpkg.com/kaplay@3001.0.19/dist/kaplay.js"></script>
<script>
// =============================================
//  SHOOT 'EM UP TEMPLATE â€” Kaplay.js
//  Arrow keys / WASD move, Z / Space to shoot
// =============================================

const C = {
    playerSpeed:    280,
    bulletSpeed:    600,
    fireRate:       0.12,
    playerHP:       5,
    // Enemies
    spawnRate:      1.2,
    enemySpeed:     [80, 200],
    enemyHP:        [1, 3],
    enemyFireRate:  1.5,
    enemyBulletSpd: 250,
    // Colors
    bg:             [6, 6, 18],
    playerCol:      [80, 220, 255],
    bulletCol:      [255, 255, 120],
    enemyBulletCol: [255, 100, 100],
};

kaplay({ width: 480, height: 700, background: C.bg, crisp: true });
loadBean();

// ---- Starfield background ----
function makeStars() {
    for (let i = 0; i < 60; i++) {
        const s = rand(0.5, 2.5);
        add([
            circle(s),
            pos(rand(0, width()), rand(0, height())),
            color(255, 255, 255),
            opacity(rand(0.15, 0.5)),
            z(-10),
            move(DOWN, rand(20, 80)),
            offscreen({ destroy: false }),
            { speed: rand(20, 80) },
            "star",
        ]);
    }
    // recycle stars
    onUpdate("star", (s) => {
        if (s.pos.y > height() + 10) {
            s.pos.y = -10;
            s.pos.x = rand(0, width());
        }
    });
}

// ---- GAME SCENE ----
scene("game", () => {
    makeStars();
    let score = 0;
    let fireTimer = 0;
    let gameOver = false;
    let spawnTimer = 0;
    let difficulty = 1;

    // -- Player --
    const player = add([
        sprite("bean"),
        pos(width() / 2, height() - 80),
        area(),
        anchor("center"),
        scale(1.2),
        z(10),
        { hp: C.playerHP, invuln: 0 },
        "player",
    ]);

    // -- HUD --
    const scoreTxt = add([
        text("0", { size: 22 }),
        pos(width() / 2, 14), anchor("top"), color(255, 220, 80), fixed(), z(50),
    ]);
    const hpTxt = add([
        text("", { size: 16 }),
        pos(16, 14), color(80, 220, 255), fixed(), z(50),
    ]);
    function updateHUD() {
        scoreTxt.text = `${score}`;
        let hearts = "";
        for (let i = 0; i < player.hp; i++) hearts += "@ ";
        hpTxt.text = hearts.trim();
    }
    updateHUD();

    // -- Movement --
    onKeyDown("left",  () => { if (!gameOver) player.move(-C.playerSpeed, 0); });
    onKeyDown("right", () => { if (!gameOver) player.move(C.playerSpeed, 0); });
    onKeyDown("up",    () => { if (!gameOver) player.move(0, -C.playerSpeed); });
    onKeyDown("down",  () => { if (!gameOver) player.move(0, C.playerSpeed); });
    onKeyDown("a",     () => { if (!gameOver) player.move(-C.playerSpeed, 0); });
    onKeyDown("d",     () => { if (!gameOver) player.move(C.playerSpeed, 0); });
    onKeyDown("w",     () => { if (!gameOver) player.move(0, -C.playerSpeed); });
    onKeyDown("s",     () => { if (!gameOver) player.move(0, C.playerSpeed); });

    // Clamp to screen
    player.onUpdate(() => {
        player.pos.x = clamp(player.pos.x, 20, width() - 20);
        player.pos.y = clamp(player.pos.y, 40, height() - 20);
        if (player.invuln > 0) {
            player.invuln -= dt();
            player.opacity = wave(0.3, 1, time() * 16);
        } else {
            player.opacity = 1;
        }
    });

    // -- Shooting (hold Z or Space) --
    onUpdate(() => {
        if (gameOver) return;
        fireTimer -= dt();
        const shooting = isKeyDown("z") || isKeyDown("space");
        if (shooting && fireTimer <= 0) {
            fireTimer = C.fireRate;
            // Twin bullets
            for (const ox of [-10, 10]) {
                add([
                    rect(4, 14, { radius: 2 }),
                    pos(player.pos.x + ox, player.pos.y - 20),
                    area(),
                    anchor("center"),
                    color(...C.bulletCol),
                    move(UP, C.bulletSpeed),
                    offscreen({ destroy: true }),
                    z(8),
                    "pbullet",
                ]);
            }
        }
    });

    // -- Enemy spawning --
    function spawnEnemy() {
        if (gameOver) return;
        const type = choose(["basic", "basic", "fast", "tank"]);
        const conf = {
            basic: { w: 26, h: 26, hp: 1, spd: rand(...C.enemySpeed), col: [200, 60, 70],  pts: 100, shoots: false },
            fast:  { w: 20, h: 20, hp: 1, spd: rand(180, 300),        col: [220, 180, 50],  pts: 150, shoots: false },
            tank:  { w: 34, h: 34, hp: 3, spd: rand(50, 100),         col: [120, 60, 200],  pts: 300, shoots: true },
        }[type];

        const e = add([
            rect(conf.w, conf.h, { radius: 4 }),
            pos(rand(30, width() - 30), -30),
            area(),
            anchor("center"),
            color(...conf.col),
            outline(2, rgb(0, 0, 0)),
            z(9),
            { hp: conf.hp, pts: conf.pts, shoots: conf.shoots, fireCD: rand(1, C.enemyFireRate) },
            "enemy",
        ]);

        // Movement pattern
        if (type === "fast") {
            // Zigzag
            e.onUpdate(() => {
                e.move(Math.sin(time() * 4 + e.pos.x) * 120, conf.spd);
            });
        } else {
            e.onUpdate(() => { e.move(0, conf.spd); });
        }

        // Shooting enemies
        if (conf.shoots) {
            e.onUpdate(() => {
                if (gameOver) return;
                e.fireCD -= dt();
                if (e.fireCD <= 0) {
                    e.fireCD = C.enemyFireRate;
                    add([
                        circle(5),
                        pos(e.pos),
                        area({ shape: new Rect(vec2(-5, -5), 10, 10) }),
                        anchor("center"),
                        color(...C.enemyBulletCol),
                        move(DOWN, C.enemyBulletSpd),
                        offscreen({ destroy: true }),
                        z(8),
                        "ebullet",
                    ]);
                }
            });
        }
    }

    // Spawn loop with increasing difficulty
    onUpdate(() => {
        if (gameOver) return;
        difficulty = 1 + score / 2000;
        spawnTimer -= dt();
        if (spawnTimer <= 0) {
            spawnTimer = C.spawnRate / difficulty;
            spawnEnemy();
        }
    });

    // -- Collisions: player bullets hit enemies --
    onCollide("pbullet", "enemy", (b, e) => {
        destroy(b);
        e.hp--;
        if (e.hp <= 0) {
            score += e.pts;
            addKaboom(e.pos);
            destroy(e);
            updateHUD();
        }
    });

    // -- Collisions: enemy bullets hit player --
    onCollide("ebullet", "player", (b) => {
        destroy(b);
        hurtPlayer();
    });

    // -- Collisions: enemies hit player --
    onCollide("enemy", "player", (e) => {
        score += e.pts;
        addKaboom(e.pos);
        destroy(e);
        hurtPlayer();
        updateHUD();
    });

    function hurtPlayer() {
        if (player.invuln > 0 || gameOver) return;
        player.hp--;
        player.invuln = 1.5;
        shake(8);
        flash(rgb(255, 80, 80), 0.12);
        updateHUD();
        if (player.hp <= 0) {
            gameOver = true;
            addKaboom(player.pos);
            player.opacity = 0;
            wait(1, () => go("gameover", score));
        }
    }

    // Cleanup off-screen enemies
    onUpdate("enemy", (e) => {
        if (e.pos.y > height() + 60) destroy(e);
    });

    // Controls hint
    add([
        text("WASD move | Z/SPACE shoot", { size: 12 }),
        pos(width() / 2, height() - 10), anchor("bot"),
        color(80, 80, 110), fixed(), z(50),
    ]);
});

// ---- GAME OVER ----
scene("gameover", (finalScore) => {
    makeStars();
    add([ text("GAME OVER", { size: 48 }), pos(center()), anchor("center"), color(220, 60, 80) ]);
    add([ text(`Score: ${finalScore}`, { size: 26 }), pos(center().x, center().y + 50), anchor("center"), color(255, 220, 80) ]);
    add([ text("Press SPACE to retry", { size: 15 }), pos(center().x, center().y + 95), anchor("center"), color(140, 140, 170) ]);
    onKeyPress("space", () => go("game"));
    onClick(() => go("game"));
});

go("game");
</script>
</body>
</html>