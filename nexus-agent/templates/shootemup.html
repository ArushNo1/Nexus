<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Kaplay Shoot 'em Up Template</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            background: #000;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="https://unpkg.com/kaplay@3001.0.19/dist/kaplay.js"></script>
    <script>
        // =============================================
        //  SHOOT 'EM UP TEMPLATE — Kaplay.js
        //  Arrow keys / WASD move, Z / Space to shoot
        //
        //  ARCHITECTURE:
        //    Two scenes: "game" (main gameplay) and "gameover" (score display + retry).
        //    Tags used: "star", "player", "pbullet" (player bullets), "enemy", "ebullet" (enemy bullets).
        //    Difficulty scales with score — spawn rate increases over time.
        //    Player has HP + invulnerability frames on hit. Three enemy types: basic, fast (zigzag), tank (shoots back).
        // =============================================

        // -- CONFIG: All tunable gameplay constants live here --
        const C = {
            playerSpeed: 280,
            bulletSpeed: 600,
            fireRate: 0.12,       // seconds between player shots (lower = faster)
            playerHP: 5,
            spawnRate: 1.2,       // base seconds between enemy spawns (divided by difficulty multiplier)
            enemySpeed: [80, 200],  // [min, max] for rand()
            enemyHP: [1, 3],
            enemyFireRate: 1.5,   // seconds between tank enemy shots
            enemyBulletSpd: 250,
            bg: [6, 6, 18],
            playerCol: [80, 220, 255],
            bulletCol: [255, 255, 120],
            enemyBulletCol: [255, 100, 100],
        };

        // -- INIT: 480x700 portrait canvas, letterboxed to fit window --
        kaplay({ width: 480, height: 700, background: C.bg, crisp: true, letterbox: true });
        loadBean(); // loads the built-in "bean" sprite used for the player

        // -- STARFIELD: Decorative scrolling background stars --
        // Stars move downward and wrap to top when off-screen. Called once per scene.
        function makeStars() {
            for (let i = 0; i < 60; i++) {
                const s = rand(0.5, 2.5);
                add([
                    circle(s),
                    pos(rand(0, width()), rand(0, height())),
                    color(255, 255, 255),
                    opacity(rand(0.15, 0.5)),
                    z(-10),
                    move(DOWN, rand(20, 80)),
                    offscreen({ destroy: false }), // keep alive when off-screen
                    { speed: rand(20, 80) },
                    "star",
                ]);
            }
            // Recycle stars: wrap from bottom to top instead of destroying
            onUpdate("star", (s) => {
                if (s.pos.y > height() + 10) {
                    s.pos.y = -10;
                    s.pos.x = rand(0, width());
                }
            });
        }

        // ==================
        //  GAME SCENE
        // ==================
        scene("game", () => {
            makeStars();
            let score = 0;
            let fireTimer = 0;    // cooldown tracker for player shooting
            let gameOver = false;  // flag to freeze input/spawning on death
            let spawnTimer = 0;    // cooldown tracker for enemy spawns
            let difficulty = 1;    // multiplier that increases with score

            // -- PLAYER: bean sprite with custom hp and invulnerability timer --
            const player = add([
                sprite("bean"),
                pos(width() / 2, height() - 80), // starts near bottom center
                area(),          // enables collision detection
                anchor("center"),
                scale(1.2),
                z(10),
                { hp: C.playerHP, invuln: 0 }, // custom state: invuln = seconds of iframes remaining
                "player",
            ]);

            // -- HUD: score (top center) and health hearts (top left) --
            const scoreTxt = add([
                text("0", { size: 22 }),
                pos(width() / 2, 14), anchor("top"), color(255, 220, 80), fixed(), z(50),
            ]);
            const hpTxt = add([
                text("", { size: 16 }),
                pos(16, 14), color(80, 220, 255), fixed(), z(50),
            ]);
            function updateHUD() {
                scoreTxt.text = `${score}`;
                let hearts = "";
                for (let i = 0; i < player.hp; i++) hearts += "@ ";
                hpTxt.text = hearts.trim();
            }
            updateHUD();

            // -- MOVEMENT: 8-directional via arrow keys and WASD --
            onKeyDown("left", () => { if (!gameOver) player.move(-C.playerSpeed, 0); });
            onKeyDown("right", () => { if (!gameOver) player.move(C.playerSpeed, 0); });
            onKeyDown("up", () => { if (!gameOver) player.move(0, -C.playerSpeed); });
            onKeyDown("down", () => { if (!gameOver) player.move(0, C.playerSpeed); });
            onKeyDown("a", () => { if (!gameOver) player.move(-C.playerSpeed, 0); });
            onKeyDown("d", () => { if (!gameOver) player.move(C.playerSpeed, 0); });
            onKeyDown("w", () => { if (!gameOver) player.move(0, -C.playerSpeed); });
            onKeyDown("s", () => { if (!gameOver) player.move(0, C.playerSpeed); });

            // Clamp player to screen bounds + handle invulnerability flicker
            player.onUpdate(() => {
                player.pos.x = clamp(player.pos.x, 20, width() - 20);
                player.pos.y = clamp(player.pos.y, 40, height() - 20);
                if (player.invuln > 0) {
                    player.invuln -= dt();
                    player.opacity = wave(0.3, 1, time() * 16); // rapid flicker effect
                } else {
                    player.opacity = 1;
                }
            });

            // -- PLAYER SHOOTING: hold Z or Space for continuous fire --
            // Spawns twin bullets (offset -10px and +10px from player center)
            onUpdate(() => {
                if (gameOver) return;
                fireTimer -= dt();
                const shooting = isKeyDown("z") || isKeyDown("space");
                if (shooting && fireTimer <= 0) {
                    fireTimer = C.fireRate;
                    for (const ox of [-10, 10]) {
                        add([
                            rect(4, 14, { radius: 2 }),
                            pos(player.pos.x + ox, player.pos.y - 20),
                            area(),
                            anchor("center"),
                            color(...C.bulletCol),
                            move(UP, C.bulletSpeed),
                            offscreen({ destroy: true }), // auto-cleanup when off-screen
                            z(8),
                            "pbullet", // tag for collision detection
                        ]);
                    }
                }
            });

            // -- ENEMY SPAWNING --
            // Three types:
            //   "basic" — moves straight down, 1 HP
            //   "fast"  — zigzags via sin(time()), 1 HP, higher speed
            //   "tank"  — slow, 3 HP, shoots bullets downward at player
            // Weighted random: basic appears 2x as often as fast/tank
            function spawnEnemy() {
                if (gameOver) return;
                const type = choose(["basic", "basic", "fast", "tank"]);
                const conf = {
                    basic: { w: 26, h: 26, hp: 1, spd: rand(...C.enemySpeed), col: [200, 60, 70], pts: 100, shoots: false },
                    fast: { w: 20, h: 20, hp: 1, spd: rand(180, 300), col: [220, 180, 50], pts: 150, shoots: false },
                    tank: { w: 34, h: 34, hp: 3, spd: rand(50, 100), col: [120, 60, 200], pts: 300, shoots: true },
                }[type];

                const e = add([
                    rect(conf.w, conf.h, { radius: 4 }),
                    pos(rand(30, width() - 30), -30), // spawn above screen
                    area(),
                    anchor("center"),
                    color(...conf.col),
                    outline(2, rgb(0, 0, 0)),
                    z(9),
                    { hp: conf.hp, pts: conf.pts, shoots: conf.shoots, fireCD: rand(1, C.enemyFireRate) },
                    "enemy",
                ]);

                // Movement: fast enemies zigzag, others go straight down
                if (type === "fast") {
                    e.onUpdate(() => {
                        e.move(Math.sin(time() * 4 + e.pos.x) * 120, conf.spd);
                    });
                } else {
                    e.onUpdate(() => { e.move(0, conf.spd); });
                }

                // Tank shooting: fires a circle bullet straight down on a cooldown
                if (conf.shoots) {
                    e.onUpdate(() => {
                        if (gameOver) return;
                        e.fireCD -= dt();
                        if (e.fireCD <= 0) {
                            e.fireCD = C.enemyFireRate;
                            add([
                                circle(5),
                                pos(e.pos),
                                area({ shape: new Rect(vec2(-5, -5), 10, 10) }), // explicit hitbox for circle
                                anchor("center"),
                                color(...C.enemyBulletCol),
                                move(DOWN, C.enemyBulletSpd),
                                offscreen({ destroy: true }),
                                z(8),
                                "ebullet", // tag for collision with player
                            ]);
                        }
                    });
                }
            }

            // -- DIFFICULTY SCALING: spawn interval shrinks as score grows --
            // difficulty = 1 + score/2000, so at 2000 pts enemies spawn 2x as fast
            onUpdate(() => {
                if (gameOver) return;
                difficulty = 1 + score / 2000;
                spawnTimer -= dt();
                if (spawnTimer <= 0) {
                    spawnTimer = C.spawnRate / difficulty;
                    spawnEnemy();
                }
            });

            // -- COLLISION: player bullets → enemies --
            // Bullet is destroyed on contact. Enemy loses 1 HP; destroyed + scored if HP reaches 0.
            onCollide("pbullet", "enemy", (b, e) => {
                destroy(b);
                e.hp--;
                if (e.hp <= 0) {
                    score += e.pts;
                    addKaboom(e.pos); // built-in explosion effect
                    destroy(e);
                    updateHUD();
                }
            });

            // -- COLLISION: enemy bullets → player --
            onCollide("ebullet", "player", (b) => {
                destroy(b);
                hurtPlayer();
            });

            // -- COLLISION: enemy body → player (kamikaze) --
            // Enemy is destroyed and scored even on body collision
            onCollide("enemy", "player", (e) => {
                score += e.pts;
                addKaboom(e.pos);
                destroy(e);
                hurtPlayer();
                updateHUD();
            });

            // -- DAMAGE HANDLER: reduces HP, triggers iframes, checks for death --
            function hurtPlayer() {
                if (player.invuln > 0 || gameOver) return; // ignore hits during iframes
                player.hp--;
                player.invuln = 1.5; // 1.5 seconds of invulnerability
                shake(8);                          // screen shake
                flash(rgb(255, 80, 80), 0.12);     // red screen flash
                updateHUD();
                if (player.hp <= 0) {
                    gameOver = true;
                    addKaboom(player.pos);
                    player.opacity = 0; // hide player sprite
                    wait(1, () => go("gameover", score)); // transition after 1s delay
                }
            }

            // Cleanup enemies that drift past the bottom of the screen
            onUpdate("enemy", (e) => {
                if (e.pos.y > height() + 60) destroy(e);
            });

            // Controls hint (bottom center, subtle)
            add([
                text("WASD move | Z/SPACE shoot", { size: 12 }),
                pos(width() / 2, height() - 10), anchor("bot"),
                color(80, 80, 110), fixed(), z(50),
            ]);
        });

        // ==================
        //  GAME OVER SCENE
        // ==================
        // Displays final score. Press Space or click anywhere to restart.
        scene("gameover", (finalScore) => {
            makeStars();
            add([text("GAME OVER", { size: 48 }), pos(center()), anchor("center"), color(220, 60, 80)]);
            add([text(`Score: ${finalScore}`, { size: 26 }), pos(center().x, center().y + 50), anchor("center"), color(255, 220, 80)]);
            add([text("Press SPACE to retry", { size: 15 }), pos(center().x, center().y + 95), anchor("center"), color(140, 140, 170)]);
            onKeyPress("space", () => go("game"));
            onClick(() => go("game"));
        });

        // -- ENTRY POINT: start on the game scene --
        go("game");
    </script>
</body>

</html>