<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Kaplay Breakout Template</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            background: #111;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="https://unpkg.com/kaplay@3001.0.19/dist/kaplay.js"></script>
    <script>
        // =============================================
        //  BREAKOUT TEMPLATE — Kaplay.js
        //
        //  HOW IT WORKS:
        //    - Move the paddle left/right (Arrow keys or mouse) to bounce the ball.
        //    - Ball bounces off walls and the paddle; breaks bricks on contact.
        //    - Clear all bricks to win. Lose all lives = game over.
        //    - Ball physics are manual (no Kaplay body) for precise control.
        //
        //  SCENES: "game", "gameover", "win"
        //
        //  EDUCATIONAL POTENTIAL:
        //    - Bricks display vocab/math — only break when player answers correctly
        //    - Ball speed increases as player answers questions
        //    - Brick arrangement spells words or forms equations
        // =============================================

        // -- CONFIG --
        const C = {
            w: 640,
            h: 480,
            paddleW: 90,         // paddle width
            paddleH: 14,         // paddle height
            paddleSpeed: 400,    // paddle keyboard speed
            paddleY: 450,        // paddle Y position
            ballR: 8,            // ball radius
            ballSpeed: 260,      // ball speed (constant)
            brickW: 56,          // brick width
            brickH: 20,          // brick height
            brickPad: 4,         // gap between bricks
            brickTopOffset: 50,  // top margin for bricks
            brickLeftOffset: 36, // left margin for bricks
            brickCols: 10,       // bricks per row
            brickRows: 5,        // rows of bricks
            lives: 3,            // starting lives
            scorePerBrick: 10,
            bg: [15, 15, 25],
            paddleCol: [80, 200, 255],
            ballCol: [255, 255, 220],
            brickColors: [       // one color per row (top to bottom)
                [220, 50, 50],
                [220, 160, 40],
                [220, 220, 50],
                [50, 200, 80],
                [50, 120, 220],
            ],
        };

        kaplay({ width: C.w, height: C.h, background: C.bg, crisp: true, letterbox: true });
        loadBean();

        // ==================
        //  GAME SCENE
        // ==================
        scene("game", () => {
            let score = 0;
            let lives = C.lives;
            let bricksLeft = 0;

            // -- SECTION: Paddle --
            const paddle = add([
                rect(C.paddleW, C.paddleH, { radius: 4 }),
                pos(C.w / 2, C.paddleY), anchor("center"),
                color(...C.paddleCol), area(),
                "paddle",
            ]);

            // Move paddle with keyboard
            onUpdate(() => {
                if (isKeyDown("left")) paddle.move(-C.paddleSpeed, 0);
                if (isKeyDown("right")) paddle.move(C.paddleSpeed, 0);
                // Clamp paddle to screen
                paddle.pos.x = Math.max(C.paddleW / 2, Math.min(C.w - C.paddleW / 2, paddle.pos.x));
            });

            // Move paddle with mouse
            onMouseMove((mpos) => {
                paddle.pos.x = Math.max(C.paddleW / 2, Math.min(C.w - C.paddleW / 2, mpos.x));
            });

            // -- SECTION: Ball --
            // Start moving up-right at a slight angle
            let ballVel = Vec2.fromAngle(-70).scale(C.ballSpeed);
            const ball = add([
                circle(C.ballR),
                pos(C.w / 2, C.paddleY - 30), anchor("center"),
                color(...C.ballCol),
                area({ shape: new Rect(vec2(-C.ballR, -C.ballR), C.ballR * 2, C.ballR * 2) }),
                "ball",
            ]);

            // -- SECTION: Ball movement and wall bouncing --
            onUpdate("ball", () => {
                ball.move(ballVel);

                // Bounce off left/right walls
                if (ball.pos.x - C.ballR <= 0) { ball.pos.x = C.ballR; ballVel.x = Math.abs(ballVel.x); }
                if (ball.pos.x + C.ballR >= C.w) { ball.pos.x = C.w - C.ballR; ballVel.x = -Math.abs(ballVel.x); }

                // Bounce off top wall
                if (ball.pos.y - C.ballR <= 0) { ball.pos.y = C.ballR; ballVel.y = Math.abs(ballVel.y); }

                // Ball fell off bottom — lose a life
                if (ball.pos.y > C.h + 20) {
                    lives--;
                    shake(8);
                    if (lives <= 0) { go("gameover", score); return; }
                    // Reset ball to center
                    ball.pos = vec2(C.w / 2, C.paddleY - 30);
                    ballVel = Vec2.fromAngle(-70).scale(C.ballSpeed);
                }
            });

            // -- SECTION: Paddle collision --
            // When ball hits paddle, bounce upward with angle based on where it hit
            onCollide("ball", "paddle", () => {
                if (ballVel.y < 0) return; // already going up, skip

                // Calculate hit offset: -1 (left edge) to +1 (right edge)
                const offset = (ball.pos.x - paddle.pos.x) / (C.paddleW / 2);
                // Angle from -150 (far left) to -30 (far right) degrees
                const angle = -90 + offset * 60;
                ballVel = Vec2.fromAngle(angle).scale(C.ballSpeed);
                ball.pos.y = C.paddleY - C.paddleH / 2 - C.ballR - 1;
            });

            // -- SECTION: Build bricks --
            for (let row = 0; row < C.brickRows; row++) {
                for (let col = 0; col < C.brickCols; col++) {
                    const x = C.brickLeftOffset + col * (C.brickW + C.brickPad);
                    const y = C.brickTopOffset + row * (C.brickH + C.brickPad);

                    add([
                        rect(C.brickW, C.brickH, { radius: 2 }),
                        pos(x, y), color(...C.brickColors[row]),
                        area(), "brick",
                    ]);
                    bricksLeft++;
                }
            }

            // -- SECTION: Ball hits brick --
            onCollide("ball", "brick", (b, brick) => {
                // Simple bounce: reverse Y direction
                ballVel.y = -ballVel.y;

                destroy(brick);
                score += C.scorePerBrick;
                bricksLeft--;
                addKaboom(brick.pos);

                // All bricks cleared = win
                if (bricksLeft <= 0) go("win", score);
            });

            // -- SECTION: HUD --
            const scoreHud = add([text("", { size: 16 }), pos(8, 8), color(255, 220, 80), fixed(), z(50)]);
            const livesHud = add([text("", { size: 16 }), pos(C.w - 8, 8), anchor("topright"), color(255, 100, 100), fixed(), z(50)]);

            onUpdate(() => {
                scoreHud.text = `Score: ${score}`;
                livesHud.text = `Lives: ${lives}`;
            });
        });

        // ==================
        //  GAME OVER
        // ==================
        scene("gameover", (score) => {
            add([text("GAME OVER", { size: 48 }), pos(center()), anchor("center"), color(220, 60, 60)]);
            add([text(`Score: ${score}`, { size: 24 }), pos(center().x, center().y + 50), anchor("center"), color(255, 220, 80)]);
            add([text("Press SPACE to retry", { size: 14 }), pos(center().x, center().y + 90), anchor("center"), color(150, 150, 180)]);
            onKeyPress("space", () => go("game"));
            onClick(() => go("game"));
        });

        // ==================
        //  WIN SCENE
        // ==================
        scene("win", (score) => {
            add([text("ALL BRICKS CLEARED!", { size: 40 }), pos(center()), anchor("center"), color(100, 255, 150)]);
            add([text(`Score: ${score}`, { size: 24 }), pos(center().x, center().y + 50), anchor("center"), color(255, 220, 80)]);
            add([text("Press SPACE to play again", { size: 14 }), pos(center().x, center().y + 90), anchor("center"), color(150, 150, 180)]);
            onKeyPress("space", () => go("game"));
            onClick(() => go("game"));
        });

        go("game");
    </script>
</body>

</html>
