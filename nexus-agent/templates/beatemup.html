<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Kaplay Beat 'em Up Template</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            background: #111;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="https://unpkg.com/kaplay@3001.0.19/dist/kaplay.js"></script>
    <script>
        // =============================================
        //  BEAT 'EM UP TEMPLATE â€” Kaplay.js
        //  Arrow keys / WASD to move, J to punch, K to kick
        // =============================================

        const C = {
            speed: 200,
            punchDmg: 20,
            kickDmg: 35,
            punchRange: 50,
            kickRange: 60,
            punchCD: 0.3,
            kickCD: 0.6,
            playerHP: 100,
            enemyHP: 60,
            spawnRate: 2.5,
            floorY: 340,
            bg: [30, 25, 40],
        };

        kaplay({ width: 800, height: 480, background: C.bg, crisp: true, letterbox: true });
        loadBean();

        // ---- Floor ----
        function drawFloor() {
            add([rect(900, 160), pos(0, C.floorY), color(50, 50, 65), z(-5)]);
            // lane lines
            for (let i = 0; i < 4; i++) {
                add([rect(900, 1), pos(0, C.floorY + 20 + i * 30), color(60, 60, 80), opacity(0.4), z(-4)]);
            }
        }

        // ---- GAME SCENE ----
        scene("game", () => {
            drawFloor();
            let score = 0;
            let canPunch = true;
            let canKick = true;
            let gameOver = false;

            // -- Player --
            const player = add([
                sprite("bean"),
                pos(100, C.floorY + 40),
                area(),
                anchor("bot"),
                z(10),
                scale(1.3),
                { hp: C.playerHP, facing: 1, stunned: false },
                "player",
            ]);

            // -- HUD --
            const hpBar = add([rect(200, 14), pos(16, 16), color(80, 200, 100), fixed(), z(50)]);
            const hpBg = add([rect(204, 18), pos(14, 14), color(30, 30, 30), fixed(), z(49)]);
            add([text("HP", { size: 14 }), pos(18, 34), color(200, 200, 200), fixed(), z(50)]);
            const scoreTxt = add([text("KO: 0", { size: 18 }), pos(width() - 16, 16), anchor("topright"), color(255, 220, 80), fixed(), z(50)]);

            function updateHP() {
                hpBar.width = Math.max(0, (player.hp / C.playerHP) * 200);
                hpBar.color = player.hp > 50 ? rgb(80, 200, 100) : player.hp > 25 ? rgb(220, 180, 40) : rgb(220, 60, 60);
            }

            // -- Movement (8-directional, clamped to floor area) --
            onKeyDown("left", () => { player.move(-C.speed, 0); player.facing = -1; player.flipX = true; });
            onKeyDown("right", () => { player.move(C.speed, 0); player.facing = 1; player.flipX = false; });
            onKeyDown("up", () => { player.move(0, -C.speed * 0.6); });
            onKeyDown("down", () => { player.move(0, C.speed * 0.6); });
            onKeyDown("a", () => { player.move(-C.speed, 0); player.facing = -1; player.flipX = true; });
            onKeyDown("d", () => { player.move(C.speed, 0); player.facing = 1; player.flipX = false; });
            onKeyDown("w", () => { player.move(0, -C.speed * 0.6); });
            onKeyDown("s", () => { player.move(0, C.speed * 0.6); });

            // Clamp player to arena
            player.onUpdate(() => {
                player.pos.x = clamp(player.pos.x, 30, width() - 30);
                player.pos.y = clamp(player.pos.y, C.floorY + 20, C.floorY + 130);
            });

            // -- Attack helper --
            function attack(range, dmg, cooldownKey, cooldownTime, col) {
                if (gameOver) return;
                const hitPos = player.pos.add(player.facing * range * 0.6, -20);
                // VFX
                const fx = add([
                    circle(range * 0.4),
                    pos(hitPos),
                    anchor("center"),
                    color(...col),
                    opacity(0.7),
                    z(15),
                    lifespan(0.15, { fade: 0.1 }),
                ]);
                // Hit detection
                const enemies = get("enemy");
                for (const e of enemies) {
                    if (e.pos.dist(hitPos) < range && Math.abs(e.pos.y - player.pos.y) < 40) {
                        e.hp -= dmg;
                        // Knockback
                        e.move(player.facing * 300, 0);
                        flash(rgb(255, 255, 255), 0.05);
                        if (e.hp <= 0) {
                            destroyEnemy(e);
                            score++;
                            scoreTxt.text = `KO: ${score}`;
                        }
                    }
                }
                shake(2);
            }

            // -- Punch (J) --
            onKeyPress("j", () => {
                if (!canPunch || gameOver) return;
                canPunch = false;
                attack(C.punchRange, C.punchDmg, "canPunch", C.punchCD, [255, 240, 150]);
                // Quick scale squash for feedback
                player.scaleTo(1.4, 1.2);
                wait(0.08, () => player.scaleTo(1.3));
                wait(C.punchCD, () => canPunch = true);
            });

            // -- Kick (K) --
            onKeyPress("k", () => {
                if (!canKick || gameOver) return;
                canKick = false;
                attack(C.kickRange, C.kickDmg, "canKick", C.kickCD, [100, 200, 255]);
                player.scaleTo(1.2, 1.4);
                wait(0.1, () => player.scaleTo(1.3));
                wait(C.kickCD, () => canKick = true);
            });

            // -- Enemy destroy effect --
            function destroyEnemy(e) {
                addKaboom(e.pos);
                destroy(e);
            }

            // -- Spawn enemies --
            function spawnEnemy() {
                if (gameOver) return;
                const fromRight = randi(0, 2) === 0;
                const ex = fromRight ? width() + 30 : -30;
                const ey = rand(C.floorY + 25, C.floorY + 125);
                const eColor = choose([
                    [200, 60, 60], [60, 160, 200], [180, 80, 180], [200, 140, 50],
                ]);

                const enemy = add([
                    rect(28, 34, { radius: 4 }),
                    pos(ex, ey),
                    area(),
                    anchor("bot"),
                    color(...eColor),
                    outline(2, rgb(0, 0, 0)),
                    z(9),
                    { hp: C.enemyHP + score * 3, spd: rand(60, 120) + score * 2, atkCD: 0, facing: 1 },
                    "enemy",
                ]);

                // Enemy AI
                enemy.onUpdate(() => {
                    if (gameOver) return;
                    const dir = player.pos.sub(enemy.pos);
                    const dist = dir.len();

                    // Face player
                    enemy.facing = dir.x > 0 ? 1 : -1;

                    if (dist > 45) {
                        enemy.move(dir.unit().scale(enemy.spd));
                    } else {
                        // Attack
                        enemy.atkCD -= dt();
                        if (enemy.atkCD <= 0) {
                            player.hp -= rand(5, 12);
                            updateHP();
                            shake(4);
                            flash(rgb(220, 60, 60), 0.08);
                            enemy.atkCD = rand(0.8, 1.5);
                            if (player.hp <= 0) {
                                gameOver = true;
                                wait(0.5, () => go("gameover", score));
                            }
                        }
                    }
                    // Clamp inside arena
                    enemy.pos.x = clamp(enemy.pos.x, 10, width() - 10);
                    enemy.pos.y = clamp(enemy.pos.y, C.floorY + 20, C.floorY + 130);
                });
            }

            // Spawn loop (gets faster over time)
            loop(C.spawnRate, () => {
                if (!gameOver) spawnEnemy();
            });
            // Initial enemies
            wait(0.5, spawnEnemy);
            wait(1.2, spawnEnemy);

            // Controls hint
            add([
                text("WASD move  |  J punch  |  K kick", { size: 13 }),
                pos(width() / 2, height() - 12),
                anchor("bot"),
                color(120, 120, 150),
                fixed(),
                z(50),
            ]);
        });

        // ---- GAME OVER ----
        scene("gameover", (finalScore) => {
            add([text("GAME OVER", { size: 52 }), pos(center()), anchor("center"), color(220, 60, 60)]);
            add([text(`Knockouts: ${finalScore}`, { size: 24 }), pos(center().x, center().y + 55), anchor("center"), color(255, 220, 80)]);
            add([text("Press SPACE to retry", { size: 16 }), pos(center().x, center().y + 100), anchor("center"), color(150, 150, 180)]);
            onKeyPress("space", () => go("game"));
            onClick(() => go("game"));
        });

        go("game");
    </script>
</body>

</html>