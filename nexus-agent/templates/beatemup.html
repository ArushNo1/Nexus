<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Kaplay Beat 'em Up Template</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            background: #111;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="https://unpkg.com/kaplay@3001.0.19/dist/kaplay.js"></script>
    <script>
        // =============================================
        //  BEAT 'EM UP TEMPLATE â€” Kaplay.js
        //  Arrow keys / WASD to move, J to punch, K to kick
        //
        //  ARCHITECTURE:
        //    Two scenes: "game" (main gameplay) and "gameover" (score + retry).
        //    Tags used: "player", "enemy". No bullet/projectile entities.
        //    Pseudo-3D: Y-axis movement simulates depth on a flat floor plane (no gravity/jumping).
        //    Vertical speed is 60% of horizontal to fake perspective foreshortening.
        //    Player Y is clamped to floor band (floorY+20 to floorY+130) to stay on the "ground".
        //    Combat: distance-based hit detection (like the fighter template), not collision-based.
        //    Difficulty scaling: enemy HP and speed both increase with score (linear).
        //    Enemies spawn on a fixed timer via loop(), with two initial enemies staggered by wait().
        // =============================================

        // -- CONFIG: All tunable gameplay constants --
        const C = {
            speed: 200,
            punchDmg: 20,
            kickDmg: 35,         // kick ~2x punch but longer cooldown
            punchRange: 50,       // distance-based hit detection radius (pixels)
            kickRange: 60,
            punchCD: 0.3,         // seconds before can punch again
            kickCD: 0.6,
            playerHP: 100,
            enemyHP: 60,          // base HP; actual = 60 + score*3 (scales with kills)
            spawnRate: 2.5,       // seconds between spawns (fixed interval, does NOT scale)
            floorY: 340,          // top edge of the walkable floor band
            bg: [30, 25, 40],
        };

        kaplay({ width: 800, height: 480, background: C.bg, crisp: true, letterbox: true });
        loadBean();

        // -- FLOOR: decorative background with horizontal lane lines for depth illusion --
        function drawFloor() {
            add([rect(900, 160), pos(0, C.floorY), color(50, 50, 65), z(-5)]);
            for (let i = 0; i < 4; i++) {
                add([rect(900, 1), pos(0, C.floorY + 20 + i * 30), color(60, 60, 80), opacity(0.4), z(-4)]);
            }
        }

        // ==================
        //  GAME SCENE
        // ==================
        scene("game", () => {
            drawFloor();
            let score = 0;        // counts total knockouts
            let canPunch = true;   // cooldown flags (same pattern as fighter template)
            let canKick = true;
            let gameOver = false;

            // -- PLAYER: bean sprite, no physics body (no gravity in beat-em-up style) --
            // Movement is purely position-based. anchor("bot") for floor alignment.
            const player = add([
                sprite("bean"),
                pos(100, C.floorY + 40),
                area(),
                anchor("bot"),
                z(10),
                scale(1.3),
                { hp: C.playerHP, facing: 1, stunned: false }, // facing: 1=right, -1=left
                "player",
            ]);

            // -- HUD: HP bar (top-left, changes color at thresholds) + KO counter (top-right) --
            const hpBar = add([rect(200, 14), pos(16, 16), color(80, 200, 100), fixed(), z(50)]);
            const hpBg = add([rect(204, 18), pos(14, 14), color(30, 30, 30), fixed(), z(49)]);
            add([text("HP", { size: 14 }), pos(18, 34), color(200, 200, 200), fixed(), z(50)]);
            const scoreTxt = add([text("KO: 0", { size: 18 }), pos(width() - 16, 16), anchor("topright"), color(255, 220, 80), fixed(), z(50)]);

            // HP bar: green > 50%, yellow 25-50%, red < 25%
            function updateHP() {
                hpBar.width = Math.max(0, (player.hp / C.playerHP) * 200);
                hpBar.color = player.hp > 50 ? rgb(80, 200, 100) : player.hp > 25 ? rgb(220, 180, 40) : rgb(220, 60, 60);
            }

            // -- MOVEMENT: 8-directional, vertical speed reduced to 60% for pseudo-3D perspective --
            // Left/right also sets facing direction and flips sprite.
            onKeyDown("left", () => { player.move(-C.speed, 0); player.facing = -1; player.flipX = true; });
            onKeyDown("right", () => { player.move(C.speed, 0); player.facing = 1; player.flipX = false; });
            onKeyDown("up", () => { player.move(0, -C.speed * 0.6); });
            onKeyDown("down", () => { player.move(0, C.speed * 0.6); });
            onKeyDown("a", () => { player.move(-C.speed, 0); player.facing = -1; player.flipX = true; });
            onKeyDown("d", () => { player.move(C.speed, 0); player.facing = 1; player.flipX = false; });
            onKeyDown("w", () => { player.move(0, -C.speed * 0.6); });
            onKeyDown("s", () => { player.move(0, C.speed * 0.6); });

            // Clamp player to walkable floor band (not full screen)
            player.onUpdate(() => {
                player.pos.x = clamp(player.pos.x, 30, width() - 30);
                player.pos.y = clamp(player.pos.y, C.floorY + 20, C.floorY + 130);
            });

            // -- ATTACK SYSTEM (shared by punch and kick) --
            // Distance-based: checks each enemy's distance to a hit point projected in front of player.
            // Also checks Y proximity (< 40px) so enemies on different "lanes" aren't hit.
            // Hits ALL enemies in range (AoE), not just the closest.
            function attack(range, dmg, cooldownKey, cooldownTime, col) {
                if (gameOver) return;
                // Hit point: offset from player center in facing direction, slightly above feet
                const hitPos = player.pos.add(player.facing * range * 0.6, -20);

                // VFX: brief circle at hit point
                const fx = add([
                    circle(range * 0.4),
                    pos(hitPos),
                    anchor("center"),
                    color(...col),
                    opacity(0.7),
                    z(15),
                    lifespan(0.15, { fade: 0.1 }),
                ]);

                // Hit detection: iterate ALL enemies, check distance + Y proximity
                const enemies = get("enemy"); // get() returns all entities with this tag
                for (const e of enemies) {
                    if (e.pos.dist(hitPos) < range && Math.abs(e.pos.y - player.pos.y) < 40) {
                        e.hp -= dmg;
                        e.move(player.facing * 300, 0); // knockback
                        flash(rgb(255, 255, 255), 0.05);
                        if (e.hp <= 0) {
                            destroyEnemy(e);
                            score++;
                            scoreTxt.text = `KO: ${score}`;
                        }
                    }
                }
                shake(2);
            }

            // -- PUNCH (J): faster cooldown, less damage, squash horizontally --
            onKeyPress("j", () => {
                if (!canPunch || gameOver) return;
                canPunch = false;
                attack(C.punchRange, C.punchDmg, "canPunch", C.punchCD, [255, 240, 150]);
                player.scaleTo(1.4, 1.2); // wider = punch
                wait(0.08, () => player.scaleTo(1.3));
                wait(C.punchCD, () => canPunch = true);
            });

            // -- KICK (K): slower cooldown, more damage, stretch vertically --
            onKeyPress("k", () => {
                if (!canKick || gameOver) return;
                canKick = false;
                attack(C.kickRange, C.kickDmg, "canKick", C.kickCD, [100, 200, 255]);
                player.scaleTo(1.2, 1.4); // taller = kick
                wait(0.1, () => player.scaleTo(1.3));
                wait(C.kickCD, () => canKick = true);
            });

            // -- ENEMY DEATH: kaboom effect + destroy --
            function destroyEnemy(e) {
                addKaboom(e.pos);
                destroy(e);
            }

            // -- ENEMY SPAWNING --
            // Enemies enter from random side (left or right edge, off-screen).
            // Y position randomized within walkable floor band.
            // DIFFICULTY SCALING: HP = base + score*3, speed = base + score*2 (linear with kills).
            function spawnEnemy() {
                if (gameOver) return;
                const fromRight = randi(0, 2) === 0;
                const ex = fromRight ? width() + 30 : -30;
                const ey = rand(C.floorY + 25, C.floorY + 125);
                const eColor = choose([
                    [200, 60, 60], [60, 160, 200], [180, 80, 180], [200, 140, 50],
                ]);

                const enemy = add([
                    rect(28, 34, { radius: 4 }),
                    pos(ex, ey),
                    area(),
                    anchor("bot"),
                    color(...eColor),
                    outline(2, rgb(0, 0, 0)),
                    z(9),
                    {
                        hp: C.enemyHP + score * 3,               // scales with kills
                        spd: rand(60, 120) + score * 2,          // scales with kills
                        atkCD: 0,                                 // cooldown timer for melee attacks
                        facing: 1,
                    },
                    "enemy",
                ]);

                // -- ENEMY AI: chase player, attack when close --
                // Moves directly toward player (no pathfinding). Attacks when within 45px.
                // Attack deals random 5-12 damage on a 0.8-1.5s cooldown.
                enemy.onUpdate(() => {
                    if (gameOver) return;
                    const dir = player.pos.sub(enemy.pos);
                    const dist = dir.len();

                    enemy.facing = dir.x > 0 ? 1 : -1;

                    if (dist > 45) {
                        // Chase: move toward player at enemy's speed
                        enemy.move(dir.unit().scale(enemy.spd));
                    } else {
                        // Melee range: attack on cooldown
                        enemy.atkCD -= dt();
                        if (enemy.atkCD <= 0) {
                            player.hp -= rand(5, 12);
                            updateHP();
                            shake(4);
                            flash(rgb(220, 60, 60), 0.08);
                            enemy.atkCD = rand(0.8, 1.5);
                            if (player.hp <= 0) {
                                gameOver = true;
                                wait(0.5, () => go("gameover", score));
                            }
                        }
                    }
                    // Keep enemies within arena bounds
                    enemy.pos.x = clamp(enemy.pos.x, 10, width() - 10);
                    enemy.pos.y = clamp(enemy.pos.y, C.floorY + 20, C.floorY + 130);
                });
            }

            // Spawn loop: fixed interval (does NOT accelerate, but enemies get stronger via scaling)
            loop(C.spawnRate, () => {
                if (!gameOver) spawnEnemy();
            });
            // Two starter enemies staggered so player isn't idle at start
            wait(0.5, spawnEnemy);
            wait(1.2, spawnEnemy);

            // Controls hint
            add([
                text("WASD move  |  J punch  |  K kick", { size: 13 }),
                pos(width() / 2, height() - 12),
                anchor("bot"),
                color(120, 120, 150),
                fixed(),
                z(50),
            ]);
        });

        // ==================
        //  GAME OVER SCENE
        // ==================
        // Displays total knockouts. Press Space or click to restart.
        scene("gameover", (finalScore) => {
            add([text("GAME OVER", { size: 52 }), pos(center()), anchor("center"), color(220, 60, 60)]);
            add([text(`Knockouts: ${finalScore}`, { size: 24 }), pos(center().x, center().y + 55), anchor("center"), color(255, 220, 80)]);
            add([text("Press SPACE to retry", { size: 16 }), pos(center().x, center().y + 100), anchor("center"), color(150, 150, 180)]);
            onKeyPress("space", () => go("game"));
            onClick(() => go("game"));
        });

        // -- ENTRY POINT --
        go("game");
    </script>
</body>

</html>